
#include <ntifs.h>
#include <ntddk.h>
#include <ntimage.h>
#include <windef.h>
#include "structs.h"
#include "Main.h"
#include "util.h"
#include "ObCallBack.h"




OB_PREOP_CALLBACK_STATUS PreCallBack(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OperationInformation);
OB_PREOP_CALLBACK_STATUS preCall(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION pOperationInformation);
PVOID  CallBackHandle = NULL;

UNICODE_STRING  GetFilePathByFileObject(PVOID FileObject)
{
	POBJECT_NAME_INFORMATION ObjetNameInfor;
	if (NT_SUCCESS(IoQueryFileDosDeviceName((PFILE_OBJECT)FileObject, &ObjetNameInfor)))
	{
		return ObjetNameInfor->Name;
	}
}
VOID EnableObType(POBJECT_TYPE ObjectType)
{
	POBJECT_TYPE_TEMP  ObjectTypeTemp = (POBJECT_TYPE_TEMP)ObjectType;
	ObjectTypeTemp->TypeInfo.SupportsObjectCallbacks = 1;
}


NTSTATUS ProtectFileByObRegisterCallbacks()
{
	OB_CALLBACK_REGISTRATION  CallBackReg;

	OB_OPERATION_REGISTRATION OperationReg[2] = { { 0 },{ 0 } };
	NTSTATUS  Status;

	EnableObType(*IoFileObjectType);
	memset(&CallBackReg, 0, sizeof(OB_CALLBACK_REGISTRATION));
	CallBackReg.Version = ObGetFilterVersion();
	CallBackReg.OperationRegistrationCount = 2;
	CallBackReg.RegistrationContext = NULL;
	RtlInitUnicodeString(&CallBackReg.Altitude, L"321000");



	//memset(OperationReg, 0, sizeof(OB_OPERATION_REGISTRATION)); 

	OperationReg[0].ObjectType = IoFileObjectType;
	OperationReg[0].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
	OperationReg[0].PreOperation = PreCallBack;


	OperationReg[1].ObjectType = PsProcessType;
	OperationReg[1].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
	OperationReg[1].PreOperation = preCall;//(POB_PRE_OPERATION_CALLBACK)


	CallBackReg.OperationRegistration = OperationReg;




	Status = ObRegisterCallbacks(&CallBackReg, &CallBackHandle);

	if (!NT_SUCCESS(Status))
	{
		Status = STATUS_UNSUCCESSFUL;
	}
	else
	{
		Status = STATUS_SUCCESS;
	}
	return Status;
}

NTSTATUS UnOb()
{
	NTSTATUS  Status = STATUS_SUCCESS;
	ObUnRegisterCallbacks(CallBackHandle);

	return Status;
}


OB_PREOP_CALLBACK_STATUS PreCallBack(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OperationInformation)
{
	UNICODE_STRING uniDosName;
	UNICODE_STRING uniFilePath;
	PFILE_OBJECT FileObject = (PFILE_OBJECT)OperationInformation->Object;
	HANDLE CurrentProcessId = PsGetCurrentProcessId();
	if (OperationInformation->ObjectType != *IoFileObjectType)
	{
		return OB_PREOP_SUCCESS;
	}

	if (FileObject->FileName.Buffer == NULL ||
		!MmIsAddressValid(FileObject->FileName.Buffer) ||
		FileObject->DeviceObject == NULL ||
		!MmIsAddressValid(FileObject->DeviceObject))
	{
		return OB_PREOP_SUCCESS;
	}
	__try
	{
		uniFilePath = GetFilePathByFileObject(FileObject);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		DbgPrint("EXCEPTION_EXECUTE_HANDLER [0x%x] !!! \n", _exception_code());
		DbgPrint("Memory Addr: %llx \n", uniFilePath);
		return OB_PREOP_SUCCESS;
	}


	if (uniFilePath.Buffer == NULL || uniFilePath.Length == 0)
	{
		return OB_PREOP_SUCCESS;
	}
	if (wcsstr(uniFilePath.Buffer, L"C:\\Users\\Kang\\Desktop\\aaa.txt"))
	{
		//DbgPrint("PID : %ld File : %wZ  %wZ\r\n", (ULONG64)CurrentProcessId, &uniDosName, &uniFilePath);


		if (FileObject->DeleteAccess == TRUE || FileObject->WriteAccess == TRUE)
		{
			if (OperationInformation->Operation == OB_OPERATION_HANDLE_CREATE)
			{

				OperationInformation->Parameters->CreateHandleInformation.DesiredAccess = 0;
			}
			if (OperationInformation->Operation == OB_OPERATION_HANDLE_DUPLICATE)
			{

				OperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess = 0;
			}

		}

		//DbgPrint("%lu", FileObject->ReadAccess);
	}
	RtlVolumeDeviceToDosName(FileObject->DeviceObject, &uniDosName);
	//DbgPrint("PID : %ld File : %wZ  %wZ\r\n", (ULONG64)CurrentProcessId, &uniDosName, &uniFilePath);
	return OB_PREOP_SUCCESS;
}




OB_PREOP_CALLBACK_STATUS
preCall(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION pOperationInformation)
{

	HANDLE pid = PsGetProcessId((PEPROCESS)pOperationInformation->Object);
	char szProcName[128] = { 0 };

	if (pOperationInformation->ObjectType != *PsProcessType)
	{
		return OB_PREOP_SUCCESS;
	}

	//DbgPrint("Process: %s", GetProcessNameFromPid(pid));

	strcpy(szProcName, GetProcessNameFromPid(pid));

	if (!_stricmp(szProcName, "---------------------------------.exe"))
	{
		if (pOperationInformation->Operation == OB_OPERATION_HANDLE_CREATE)
		{
			//DbgPrint("Code : %lx", pOperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess);

			if ((pOperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_TERMINATE) == PROCESS_TERMINATE)
			{
				//Terminate the process, such as by calling the user-mode TerminateProcess routine..
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_TERMINATE;
			}

			if ((pOperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_VM_OPERATION) == PROCESS_VM_OPERATION)
			{
				//Modify the address space of the process, such as by calling the user-mode WriteProcessMemory and VirtualProtectEx routines.
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_VM_OPERATION;
			}

			if ((pOperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_VM_READ) == PROCESS_VM_READ)
			{
				//Read to the address space of the process, such as by calling the user-mode ReadProcessMemory routine.
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_VM_READ;
			}
			if ((pOperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_VM_WRITE) == PROCESS_VM_WRITE)
			{
				//Write to the address space of the process, such as by calling the user-mode WriteProcessMemory routine.
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_VM_WRITE;
			}
		}
	}


	//strcpy(szProcName, GetProcessImageNameByProcessID((ULONG)pid));
	//DbgPrint("Process: %s",szProcName);

	return OB_PREOP_SUCCESS;
}