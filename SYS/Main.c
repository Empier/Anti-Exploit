//http://www.cnblogs.com/aliflycoris/p/5468175.html

#pragma warning( disable: 4703)

#include <ntifs.h>
#include <ntddk.h>
#include <ntimage.h>
#include <windef.h>
#include <wdm.h>
#include "util.h"
#include "Main.h"
#include "structs.h"
#include "ObCallBack.h"
#include "FLT.h"

#define ProtectProcessCount 100

wchar_t DLLBuffer[1024];
wchar_t TEMPDLLBuffer[1024];

ULONG ApcStateOffset;
PKAPC_STATE ApcState;


BOOL Power = 1;



UNICODE_STRING linkNameUnicodeString;
UNICODE_STRING deviceNameUnicodeString;

UNICODE_STRING ProcessImageName;

struct protect_process
{
	int flag;
	char name[100];
} pp[101];



static BOOL	EqualModuleName(PUNICODE_STRING ModuleName, PUNICODE_STRING OtherName)
{
	BOOL Ret = FALSE;

	if (ModuleName && (ModuleName->Length >= OtherName->Length))
	{
		UNICODE_STRING	ShortName;
		ShortName.Length = OtherName->Length;
		ShortName.MaximumLength = OtherName->Length;
		ShortName.Buffer = (PWSTR)((PCHAR)ModuleName->Buffer + ModuleName->Length - ShortName.Length);
		Ret = (BOOL)RtlEqualUnicodeString(&ShortName, OtherName, TRUE);
	}
	return(Ret);
}

NTSTATUS DefaultPass(PDEVICE_OBJECT DeviceObject, PIRP pIrp)
{
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS MyControl(PDEVICE_OBJECT DeviceObject, PIRP pIrp)
{
	pIrp->IoStatus.Status = STATUS_SUCCESS;

	NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
	PIO_STACK_LOCATION IrpSp;
	ULONG FunctionCode;
	IrpSp = IoGetCurrentIrpStackLocation(pIrp);
	FunctionCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;
	//DbgPrint("code=%x",FunctionCode);
	switch (FunctionCode)
	{
	case IOCTL_InitDriver:
		ntStatus = STATUS_SUCCESS;
		//__writecr0(__readcr0() & ~0x10000);

		wcscpy(DLLBuffer, pIrp->AssociatedIrp.SystemBuffer);

		for (int i = 0; i < ProtectProcessCount; i++)
		{
			pp[i].flag = 0;
		}

		//Target Process Clean
		DbgPrint("Init Driver!");
		break;

	case IOCTL_Power_OnOff:
		ntStatus = STATUS_SUCCESS;
		//DbgPrint("%d", *(DWORD *)(pIrp->AssociatedIrp.SystemBuffer));
		//pIrp->AssociatedIrp.SystemBuffer
		Power = *(DWORD *)(pIrp->AssociatedIrp.SystemBuffer);
		//1 start

		break;

	case IOCTL_Change_Target:
		ntStatus = STATUS_SUCCESS;

		//__writecr0(__readcr0() & ~0x10000);
		/*
		struct input
		{
		char processname[64];
		} *pinp, inp;
		*/
		char *pinp;

		pinp = pIrp->AssociatedIrp.SystemBuffer;

		for (int i = 0; i < ProtectProcessCount; i++)
		{
			if (pp[i].flag == 0)
			{
				//DbgPrint("PN: %s", pinp);
				strncpy(pp[i].name, pinp, 100);
				pp[i].flag = 1;
				break;
			}
		}

		//__writecr0(__readcr0() | 0x10000);
		break;


	case IOCTL_Clean_Target:
		ntStatus = STATUS_SUCCESS;
		for (int i = 0; i < ProtectProcessCount; i++)
		{
			pp[i].flag = 0;
		}
		break;

	default:

		ntStatus = STATUS_SUCCESS;
		break;
	}



	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;


	return ntStatus;
}






void ThreadProc(IN PVOID StartContext)
{
	LARGE_INTEGER delay;
	delay.QuadPart = -1 * 2000000;

	DbgPrint("Create Kernel Thread!");
	KeDelayExecutionThread(KernelMode, FALSE, &delay); // Wait for the injection to complete


}



LPSTR GetProcessNameFromPid(HANDLE pid) {

	PEPROCESS Process;

	if (PsLookupProcessByProcessId(pid, &Process) == STATUS_INVALID_PARAMETER) {
		return "[ SelfProtect ] [ ERROR ]  PID required.";
	}

	return (LPSTR)PsGetProcessImageFileName(Process);

}

VOID _stdcall MyLoadImageNotifyRoutine(PUNICODE_STRING	FullImageName, HANDLE	ProcessId, PIMAGE_INFO ImageInfo)
{
	int RoutineFlag = 0;

	LPSTR processName;
	processName = GetProcessNameFromPid(ProcessId);


	if (Power != 1)
	{
		return;
	}
	try //BSOD 
	{
	for (int i = 0; i < ProtectProcessCount; i++)
	{
		if (pp[i].flag == 1)
		{
			
				if (!_stricmp(pp[i].name, processName, 100))
				{
					RoutineFlag = 1;
					break;
				}
			}
			
		}
	}
	except(EXCEPTION_EXECUTE_HANDLER) {
		RoutineFlag = 0;
	}

	//DbgPrint("In! %s",  processName);

	if (!RoutineFlag)
		return;
	/*
	if (!_stricmp(processName, "iexplore.exe")) {
	//DbgPrint("[ kernelAPC ] It's notepad.exe \n");
	if (ProcessId != 0 && FullImageName != NULL && FullImageName->Length > 0 && wcsstr(FullImageName->Buffer, L"ntdll.dll"))
	{
	DbgPrint("[ kernelAPC ] It's ntdll.dll \n");
	}

	}
	else {
	return;
	}
	*/

	// check If ntdll is loading
	if (ProcessId != 0 && FullImageName != NULL && FullImageName->Length > 0 && wcsstr(FullImageName->Buffer, L"ntdll.dll"))
	{


		NTSTATUS status = STATUS_SUCCESS;
		PEPROCESS pProcess = NULL;
		status = PsLookupProcessByProcessId(ProcessId, &pProcess);
		BOOLEAN isWow64 = (PsGetProcessWow64Process(pProcess) != NULL) ? TRUE : FALSE;


		// check if 64 bit ntdll is loading in 32 bit process
		if (isWow64 && wcsstr(FullImageName->Buffer, L"System32"))
			return;

		// check if target process is protected
		if (PsIsProtectedProcess(pProcess))
			return;

		if (NT_SUCCESS(status))
		{
			KAPC_STATE apc;
			UNICODE_STRING ustrPath;
			PVOID pNtdll = NULL;
			PVOID LdrLoadDllLocal = NULL;

			KeStackAttachProcess(pProcess, &apc); //KeAttachProcess

												  
			pNtdll = ImageInfo->ImageBase;

			// Get LdrLoadDll addresss
			LdrLoadDllLocal = SWIDGetModuleExport(pNtdll, "LdrLoadDll", pProcess, NULL);

			if (!LdrLoadDllLocal)
			{
				DPRINT("System Wide Injection Driver: %s: Failed to get LdrLoadDll address.\n", __FUNCTION__);
				status = STATUS_NOT_FOUND;
				KeUnstackDetachProcess(&apc);
				return;
			}

			// Call LdrLoadDll
			if (NT_SUCCESS(status))
			{
				PINJECT_BUFFER pUserBuf;
				if (isWow64)
				{
					wcscpy(TEMPDLLBuffer, DLLBuffer);
					wcscat(TEMPDLLBuffer, L"stscae32.dll");
					//DbgPrint("DLL : %wZ", TEMPDLLBuffer);
					RtlInitUnicodeString(&ustrPath, TEMPDLLBuffer);
					pUserBuf = SWIDGetWow64Code(LdrLoadDllLocal, &ustrPath);
				}
				else
				{
					wcscpy(TEMPDLLBuffer, DLLBuffer);
					wcscat(TEMPDLLBuffer, L"stscae64.dll");

					RtlInitUnicodeString(&ustrPath, TEMPDLLBuffer);
					pUserBuf = SWIDGetNativeCode(LdrLoadDllLocal, &ustrPath);
				}
				
				status = SWIDApcInject(pUserBuf, (HANDLE)ProcessId);
				//DPRINT("After SWIDApcInject() \n", __FUNCTION__);

				

			}

			KeUnstackDetachProcess(&apc);
		}
		else
		{
			DPRINT("System Wide Injection Driver: %s: PsLookupProcessByProcessId failed with status 0x%X.\n", __FUNCTION__, status);

			if (pProcess)
				ObDereferenceObject(pProcess);

			return;
		}

		if (pProcess)
			ObDereferenceObject(pProcess);
	}
	else if (ProcessId != 0 && FullImageName != NULL && FullImageName->Length > 0)
	{
		NTSTATUS status = STATUS_SUCCESS;
		PEPROCESS pProcess = NULL;
		status = PsLookupProcessByProcessId(ProcessId, &pProcess);
		BOOLEAN isWow64 = (PsGetProcessWow64Process(pProcess) != NULL) ? TRUE : FALSE;

		if (isWow64 && wcsstr(FullImageName->Buffer, L"System32"))
			return;

		if (PsIsProtectedProcess(pProcess))
			return;

		//DbgPrint("%s - %ws",processName,FullImageName->Buffer);
		LoadImageInfo(processName, FullImageName);

	}


}




NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegisterPath)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PEPROCESS Process;
	PETHREAD Thread;
	PULONG ptr;

	PDEVICE_OBJECT pMyDevice;


	int i = 0;
	for (i = 0; i < ProtectProcessCount; i++)
	{
		pp[i].flag = 0;
	}

	DbgPrint("___[Empire Kernel Load]___");

	FLTENTRY(DriverObject, RegisterPath);

#ifdef _WIN64  
	PLDR_DATA_TABLE_ENTRY64 ldr;
	ldr = (PLDR_DATA_TABLE_ENTRY64)
		DriverObject->DriverSection;
#else  
	PLDR_DATA_TABLE_ENTRY ldr;
	ldr = (PLDR_DATA_TABLE_ENTRY)
		DriverObject->DriverSection;
#endif  
	ldr->Flags |= 0x20;

	//ProtectFileByObRegisterCallbacks(); //x64?


	for (int nIndex = 0; nIndex < IRP_MJ_MAXIMUM_FUNCTION; nIndex++)
	{
		DriverObject->MajorFunction[nIndex] = DefaultPass;
	}

	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MyControl;

	Status = PsSetLoadImageNotifyRoutine(&MyLoadImageNotifyRoutine);

	DriverObject->DriverUnload = UnLoadDriver;






	RtlInitUnicodeString(&deviceNameUnicodeString, L"\\Device\\Empire");
	Status = IoCreateDevice(DriverObject, 4, &deviceNameUnicodeString, FILE_DEVICE_UNKNOWN, 0, TRUE, &pMyDevice);
	if (!NT_SUCCESS(Status))
	{
		DbgPrint("Failed to create the device!\n");
		return Status;
	}

	RtlInitUnicodeString(&linkNameUnicodeString, L"\\DosDevices\\Empire");
	Status = IoCreateSymbolicLink(&linkNameUnicodeString, &deviceNameUnicodeString);
	if (!NT_SUCCESS(Status))
	{
		DbgPrint("Failed to create the symlink\n");
		return Status;
	}


	Status = STATUS_SUCCESS;

	return Status;
}





NTSTATUS UnLoadDriver(PDRIVER_OBJECT DriverObject)
{

	NTSTATUS Status = STATUS_SUCCESS;
	DbgPrint("___[Empire Kernel Unload Success!]___");
	IoDeleteSymbolicLink(&linkNameUnicodeString);
	IoDeleteDevice(DriverObject->DeviceObject);

	PsRemoveLoadImageNotifyRoutine(&MyLoadImageNotifyRoutine);
	FLTUNLOAD();

	//UnOb();

Exit0:
	return Status;
}
