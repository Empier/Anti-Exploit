#include "Loader.h"

Loader::Loader(PTCHAR _driverName)
{
	driverName = _driverName;
}

Loader::~Loader(void)
{

}

BOOLEAN Loader::InstallDriver(void)
{
	printf("Install Driver\n");

	if (SetDriverByService())
	{
		return SetReg();
	}

	return FALSE;
}

BOOLEAN Loader::UnInstallDriver(void)
{
	printf("Uninstall Driver\n");

	return ResetDriverByService();
}

BOOLEAN Loader::StartDriver(void)
{
	BOOLEAN ret = TRUE;
	HRESULT hr;

	printf("Start Driver.\n");

	EnablePrivilege(_T("SeLoadDriverPrivilege"));
	
	hr = FilterLoad(L"stscae64");

	if (FAILED(hr))
	{
		if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr)
		{
			printf("The minifilter driver is already exists.\n");
		}
		else if (HRESULT_FROM_WIN32(ERROR_SERVICE_ALREADY_RUNNING) == hr)
		{
			printf("The minifilter driver is already running.\n");
		}
		else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
		{
			printf("No matching minifilter driver was found.\n");
			ret = FALSE;
		}
		else if (HRESULT_FROM_WIN32(ERROR_BAD_EXE_FORMAT) == hr)
		{
			printf("ERROR_BAD_EXE_FORMAT.\n");
			ret = FALSE;
		}
		else if (HRESULT_FROM_WIN32(ERROR_BAD_DRIVER) == hr)
		{
			printf("ERROR_BAD_DRIVER.\n");
			ret = FALSE;
		}
		else if (HRESULT_FROM_WIN32(ERROR_INVALID_IMAGE_HASH) == hr)
		{
			printf("ERROR_INVALID_IMAGE_HASH.\n");
			ret = FALSE;
		}
		else
		{
			printf("unknown.\n");
			ret = FALSE;
		}
	}
	else
	{
		printf("The minifilter driver is loaded successful.\n");
	}

	return ret;
}

BOOLEAN Loader::StopDriver(void)
{
	HRESULT hr;

	printf("Stop Driver.\n");
	EnablePrivilege(_T("SeLoadDriverPrivilege"));
	hr = FilterUnload(L"stscae64"); //
	if (SUCCEEDED(hr))
	{
		printf("The minifilter driver is unloaded successful.\n");
		return TRUE;
	}
	else
	{
		printf("Fail unload the minifilter.\n");
		return FALSE;
	}
}

BOOLEAN Loader::SetReg(void)
{
	printf("SetDriverReg\n");
	if (!SetDriverReg())
	{
		return FALSE;
	}

	printf("SetDriverInstanceReg\n");
	if (!SetDriverInstanceReg())
	{
		return FALSE;
	}

	printf("SetDriverInstanceSubReg\n");
	if (!SetDriverInstanceSubReg())
	{
		return FALSE;
	}

	return TRUE;
}

BOOLEAN Loader::SetDriverReg(void)
{
	HKEY hKey;
	TCHAR buffer[MAX_PATH];
	DWORD dwVal = 0;
	
	StringCchPrintf(buffer,
		MAX_PATH,
		_T("SYSTEM\\CurrentControlSet\\Services\\%s"),
		driverName);

	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		buffer,
		0,
		KEY_WRITE,
		&hKey))
	{
		return FALSE;
	}
	
	if (RegSetValueEx(hKey,
		_T("Description"),
		0,
		REG_SZ,
		(LPBYTE)driverName,
		(DWORD)(lstrlen(driverName) + 1) * sizeof(TCHAR)))
	{
		RegCloseKey(hKey);
		return FALSE;
	}
	
	dwVal = 1;
	if (RegSetValueEx(hKey,
		_T("ErrorControl"),
		0,
		REG_DWORD,
		(LPBYTE)&dwVal,
		sizeof(DWORD)))
	{
		RegCloseKey(hKey);
		return FALSE;
	}
	
	dwVal = 8;
	if (RegSetValueEx(hKey,
		_T("Tag"),
		0,
		REG_DWORD,
		(LPBYTE)&dwVal,
		sizeof(DWORD)))
	{
		RegCloseKey(hKey);
		return FALSE;
	}
	
	dwVal = 2;
	if (RegSetValueEx(hKey,
		_T("Type"),
		0,
		REG_DWORD,
		(LPBYTE)&dwVal,
		sizeof(DWORD)))
	{
		RegCloseKey(hKey);
		return FALSE;
	}
	
	if (RegSetValueEx(hKey,
		_T("Group"),
		0,
		REG_SZ,
		(LPBYTE)_T("FSFilter Test"),
		(DWORD)(lstrlen(_T("FSFilter Test")) + 1) * sizeof(TCHAR)))
	{
		RegCloseKey(hKey);
		return FALSE;
	}

	if (RegSetValueEx(hKey,
		_T("DependOnService"),
		0,
		REG_MULTI_SZ,
		(LPBYTE)_T("FltMgr"),
		(DWORD)(lstrlen(_T("FltMgr")) + 1) * sizeof(TCHAR)))
	{
		RegCloseKey(hKey);
		return FALSE;
	}

	if (RegSetValueEx(hKey,
		_T("DependOnGroup"),
		0,
		REG_MULTI_SZ,
		0,
		0))
	{
		RegCloseKey(hKey);
		return FALSE;
	}
	
	RegCloseKey(hKey);
	return TRUE;
}

BOOLEAN Loader::SetDriverInstanceReg(void)
{
	// 하위키 Instances
	HKEY hKey;
	TCHAR buffer[MAX_PATH];
	DWORD dwRet;
	DWORD dwVal = 0;
	
	StringCchPrintf(buffer,
		MAX_PATH,
		_T("SYSTEM\\CurrentControlSet\\Services\\%s\\Instances"),
		driverName);

	// 레지스트리를 생성한다.
	if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		buffer,
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		KEY_WRITE,
		NULL,
		&hKey,
		&dwRet))
	{
		return FALSE;
	}

	TCHAR defaultInstance[MAX_PATH];
	StringCchPrintf(defaultInstance,
		MAX_PATH,
		_T("%s Instance"),
		driverName);

	if (RegSetValueEx(hKey,
		_T("DefaultInstance"),
		0,
		REG_SZ,
		(LPBYTE)defaultInstance,
		(DWORD)(lstrlen(defaultInstance) + 1) * sizeof(TCHAR)))
	{
		RegCloseKey(hKey);
		return FALSE;
	}

	RegCloseKey(hKey);
	return TRUE;
}

BOOLEAN Loader::SetDriverInstanceSubReg(void)
{
	HKEY hKey;
	TCHAR buffer[MAX_PATH];
	DWORD dwRet;
	DWORD dwVal = 0;
	TCHAR defaultInstance[MAX_PATH];
	
	StringCchPrintf(defaultInstance,
		MAX_PATH,
		_T("%s Instance"),
		driverName);

	StringCchPrintf(buffer,
		MAX_PATH,
		_T("SYSTEM\\CurrentControlSet\\Services\\%s\\Instances\\%s"),
		driverName,
		defaultInstance);

	if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		buffer,
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		KEY_WRITE,
		NULL,
		&hKey,
		&dwRet))
	{
		return FALSE;
	}

	if (RegSetValueEx(hKey,
		_T("Altitude"),
		0,
		REG_SZ,
		(LPBYTE)_T("370040"),
		(DWORD)(lstrlen(_T("370040")) + 1) * sizeof(TCHAR)))
	{
		RegCloseKey(hKey);
		return FALSE;
	}

	dwVal = 0;
	if (RegSetValueEx(hKey,
		_T("Flags"),
		0,
		REG_DWORD,
		(LPBYTE)&dwVal,
		sizeof(DWORD)))
	{
		RegCloseKey(hKey);
		return FALSE;
	}

	RegCloseKey(hKey);
	return TRUE;
}

BOOLEAN Loader::SetDriverByService(void)
{
	TCHAR driverPath[MAX_PATH];
	TCHAR windowsDir[MAX_PATH];

	printf("Set Driver By Service.\n");
	/*
	GetWindowsDirectory(windowsDir, MAX_PATH);
	StringCchPrintf(driverPath,
		MAX_PATH,
		_T("%s\\System32\\Drivers\\%s.sys\0"),
		windowsDir,
		driverName);
	*/
	GetCurrentDirectoryA(MAX_PATH, driverPath);
	strcat(driverPath, "\\stscae64.sys");



	SC_HANDLE scManager;
	SC_HANDLE scService;

	scManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (!scManager)
	{
		return FALSE;
	}
	//printf("%s %s\n", driverPath,driverName);
	DWORD tagid = 8;
	scService = CreateServiceA(scManager,		// handle of service control manager database
		driverName,								// address of name of service to start
		driverName,								// address of display name
		SERVICE_ALL_ACCESS,						// type of access to service
		2,					// type of service
		1,					// when to start service
		SERVICE_ERROR_NORMAL,					// severity if service fails to start
		driverPath,								// address of name of binary file
		NULL,									// service does not belong to a group
		NULL,									// no tag requested
		NULL,									// no dependency names
		NULL,									// use LocalSystem account
		NULL									// no password for service account
		);


	
	if (scService == NULL)
	{
		DWORD dwError = GetLastError();

		if (dwError == ERROR_SERVICE_EXISTS)
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	
	CloseServiceHandle(scService);

	return TRUE;
}

BOOLEAN Loader::ResetDriverByService(void)
{
	BOOLEAN ret = TRUE;
	SC_HANDLE scManager;
	SC_HANDLE scService;

	printf("Reset Driver By Service.\n");

	scManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (!scManager)
	{
		return FALSE;
	}

	scService = OpenService(scManager, driverName, SERVICE_ALL_ACCESS);
	if (scService == NULL)
	{
		CloseServiceHandle(scManager);
		return FALSE;
	}

	if (!DeleteService(scService))
	{
		ret = FALSE;
	}

	CloseServiceHandle(scService);
	CloseServiceHandle(scManager);
	return ret;
}

DWORD Loader::EnablePrivilege(TCHAR * privilegeStr)
{
	HANDLE hToken;			// process token
	TOKEN_PRIVILEGES tp;				// token provileges
	TOKEN_PRIVILEGES oldtp;			// old token privileges
	DWORD dwSize = sizeof (TOKEN_PRIVILEGES);
	LUID luid;

	if (!OpenProcessToken(GetCurrentProcess(),
		TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
		&hToken))
	{
		return GetLastError();
	}

	if (!LookupPrivilegeValue(NULL, privilegeStr, &luid))
	{
		CloseHandle(hToken);
		return GetLastError();
	}

	memset(&tp, 0, sizeof (tp));
	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	// Adjust Token privileges
	if (!AdjustTokenPrivileges(hToken,
		FALSE,
		&tp,
		sizeof(TOKEN_PRIVILEGES),
		&oldtp,
		&dwSize))
	{
		CloseHandle(hToken);
		return GetLastError();
	}

	CloseHandle(hToken);
	return ERROR_SUCCESS;
}