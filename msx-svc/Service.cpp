// util.cpp: implementation of the util class.
//
//////////////////////////////////////////////////////////////////////

#include "Service.h"

extern const char* S_NAME;
extern const char* S_DISP;
extern const char* S_DESC;
extern SERVICE_STATUS_HANDLE srvhd;
extern DWORD                 srvst;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////



DWORD ServiceInstall()
{
	DWORD RET = ERROR_SUCCESS;
	SERVICE_DESCRIPTION lpDes;
	SC_HANDLE hSrv;
	char S_BINARY[MAX_PATH] = { 0 };
	::GetModuleFileName(NULL, S_BINARY, MAX_PATH);

	// SCM 을 열어서 서비스에 작업을 진행할 수 있도록 핸들을 하나 달라고 하자.
	// 지금 할 작업은 새로운 서비스를 만들어 등록하는 작업이다.
	SC_HANDLE hScm = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);

	// 열지 못하면 에러다. 머 어쩔 수 없다. 왜 그런지 에러 코드나 리턴한다.
	if (hScm == NULL)
		return GetLastError();

	// SCM 을 서비스 생성 권한으로 열었으니, 서비스를 만들어야지..
	// 함수에 필요한 인자들을 채워서 넣어주면 된다. 
	// 첫번째 인자는 SCM 에서 넘겨준 핸들이고 나머지는 밑에다가 추가적으로 설명을 단다.
	hSrv = CreateService(
		hScm,
		S_NAME,
		S_DISP,
		SERVICE_ALL_ACCESS,
		SERVICE_WIN32_OWN_PROCESS,
		SERVICE_AUTO_START,
		SERVICE_ERROR_IGNORE,
		S_BINARY,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL);

	// 서비스 생성이 실패하면 별수 없다. 여러가지 이유가 있을 테니까..
	// 에러 코드나 리턴하자.
	if (hSrv == NULL)
	{
		RET = GetLastError();
		CloseServiceHandle(hScm);
		return RET;
	}
	else
	{
		// 와우 서비스 생성에 성공했네...
		// 서비스 관리자 (services.msc) 를 열어보면 해당 서비스마다, 친절하게 이건 무신 무신 서비스 입니다.
		// 라는 설명을 보았을 것이다. 그와 같은 설명을 달아주는 부분이다.
		// 구지 설명 달아줄 필요가 없으면 건너 띄어도 무방하다.
		lpDes.lpDescription = (char*)S_DESC;
		if (!ChangeServiceConfig2(hSrv, SERVICE_CONFIG_DESCRIPTION, &lpDes))
		{
			RET = GetLastError();
			CloseServiceHandle(hScm);
			CloseServiceHandle(hSrv);
			return RET;
		}

		CloseServiceHandle(hScm);
		return CloseServiceHandle(hSrv) ? ERROR_SUCCESS : GetLastError();
	}
}

DWORD ServiceUninstall()
{
#define ERROR_RETURN { RET = GetLastError(); goto ERROR_LABEL; }

	// SCM 을 열어서 서비스에 작업을 진행할 수 있도록 핸들을 하나 달라고 하자.
	// 지금 할 작업은 새로운 서비스를 만들어 등록하는 작업이다.
	SC_HANDLE hSrv;
	DWORD RET = ERROR_SUCCESS;
	DWORD dwType;
	int loop = 0;
	SERVICE_STATUS ss;
	SC_HANDLE hScm = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);


	// 열지 못하면 에러다. 머 어쩔 수 없다. 왜 그런지 에러 코드나 리턴한다.
	if (hScm == NULL)
		return GetLastError();


	// 서비스 관리자를 열었으니, 이제 서비스를 직접 열어보자.
	hSrv = OpenService(hScm, S_NAME, SERVICE_ALL_ACCESS);
	if (hSrv == NULL)
		ERROR_RETURN;


	// 관리자를 열어으면, 이젠 서비스의 상태를 읽어오자.
	// 서비스를 제거하려면 먼저, 서비스를 멈추어야 한다.
	loop = 0;
	do
	{
		ControlService(hSrv, SERVICE_CONTROL_INTERROGATE, &ss);
		Sleep(1);
	} while (++loop <10);
	dwType = ss.dwCurrentState;


	// 만약 서비스의 상태가 멈춤이 아니면, 서비스를 중지 시키자.
	if (dwType != SERVICE_STOPPED)
	{
		if (!ControlService(hSrv, SERVICE_CONTROL_STOP, &ss))
			ERROR_RETURN;
	}


	// 아주 무식한 방법으로, 서비스가 멈출 때 까지 기다린다.
	// 하지만 서비스를 멈춰야 하는데, 멈추지 않는다면?
	// 서비스를 제작한 사람을 쪼아야지.. 불쌍한 서비스 제거 
	// 프로그램이 먹통되었다고 화내면 건강에 해롭다.

	// 만약 서비스를 멈추지 않고, 동작중인데 DeleteService를 
	// 이용하여 제거하면, 컴터를 리부팅 하기 전까지는 다시 
	// 설치가 불가능하다.
	do
	{
		Sleep(100);

		loop = 0;
		do
		{
			ControlService(hSrv, SERVICE_CONTROL_INTERROGATE, &ss);
			Sleep(1);
		} while (++loop <10);
		dwType = ss.dwCurrentState;
	} while (dwType != SERVICE_STOPPED);


	// 멈추어졌으면 제거한다.
	if (!DeleteService(hSrv))
		ERROR_RETURN;

ERROR_LABEL:
	if (hSrv)
		CloseServiceHandle(hSrv);
	if (hScm)
		CloseServiceHandle(hScm);

	return RET;
}

VOID SET_SERVICE_STATE(SERVICE_STATUS_HANDLE hd, DWORD dwState, DWORD dwAccept)
{
	if (srvst == dwState)
		return;

	SERVICE_STATUS ss;
	ss.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
	ss.dwCurrentState = dwState;
	ss.dwControlsAccepted = dwAccept;
	ss.dwWin32ExitCode = 0;
	ss.dwServiceSpecificExitCode = 0;
	ss.dwCheckPoint = 0;
	ss.dwWaitHint = 0;

	srvst = dwState;
	SetServiceStatus(hd, &ss);
}

DWORD GET_SERVICE_STATE()
{
	return srvst;
}
