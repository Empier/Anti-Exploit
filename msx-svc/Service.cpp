// util.cpp: implementation of the util class.
//
//////////////////////////////////////////////////////////////////////

#include "Service.h"

extern const char* S_NAME;
extern const char* S_DISP;
extern const char* S_DESC;
extern SERVICE_STATUS_HANDLE srvhd;
extern DWORD                 srvst;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////



DWORD ServiceInstall()
{
	DWORD RET = ERROR_SUCCESS;
	SERVICE_DESCRIPTION lpDes;
	SC_HANDLE hSrv;
	char S_BINARY[MAX_PATH] = { 0 };
	::GetModuleFileName(NULL, S_BINARY, MAX_PATH);

	
	SC_HANDLE hScm = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);


	if (hScm == NULL)
		return GetLastError();

	
	hSrv = CreateService(
		hScm,
		S_NAME,
		S_DISP,
		SERVICE_ALL_ACCESS,
		SERVICE_WIN32_OWN_PROCESS,
		SERVICE_AUTO_START,
		SERVICE_ERROR_IGNORE,
		S_BINARY,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL);


	if (hSrv == NULL)
	{
		RET = GetLastError();
		CloseServiceHandle(hScm);
		return RET;
	}
	else
	{

		lpDes.lpDescription = (char*)S_DESC;
		if (!ChangeServiceConfig2(hSrv, SERVICE_CONFIG_DESCRIPTION, &lpDes))
		{
			RET = GetLastError();
			CloseServiceHandle(hScm);
			CloseServiceHandle(hSrv);
			return RET;
		}

		CloseServiceHandle(hScm);
		return CloseServiceHandle(hSrv) ? ERROR_SUCCESS : GetLastError();
	}
}

DWORD ServiceUninstall()
{
#define ERROR_RETURN { RET = GetLastError(); goto ERROR_LABEL; }


	SC_HANDLE hSrv;
	DWORD RET = ERROR_SUCCESS;
	DWORD dwType;
	int loop = 0;
	SERVICE_STATUS ss;
	SC_HANDLE hScm = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);


	if (hScm == NULL)
		return GetLastError();


	hSrv = OpenService(hScm, S_NAME, SERVICE_ALL_ACCESS);
	if (hSrv == NULL)
		ERROR_RETURN;


	loop = 0;
	do
	{
		ControlService(hSrv, SERVICE_CONTROL_INTERROGATE, &ss);
		Sleep(1);
	} while (++loop <10);
	dwType = ss.dwCurrentState;


	if (dwType != SERVICE_STOPPED)
	{
		if (!ControlService(hSrv, SERVICE_CONTROL_STOP, &ss))
			ERROR_RETURN;
	}


	do
	{
		Sleep(100);

		loop = 0;
		do
		{
			ControlService(hSrv, SERVICE_CONTROL_INTERROGATE, &ss);
			Sleep(1);
		} while (++loop <10);
		dwType = ss.dwCurrentState;
	} while (dwType != SERVICE_STOPPED);


	if (!DeleteService(hSrv))
		ERROR_RETURN;

ERROR_LABEL:
	if (hSrv)
		CloseServiceHandle(hSrv);
	if (hScm)
		CloseServiceHandle(hScm);

	return RET;
}

VOID SET_SERVICE_STATE(SERVICE_STATUS_HANDLE hd, DWORD dwState, DWORD dwAccept)
{
	if (srvst == dwState)
		return;

	SERVICE_STATUS ss;
	ss.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
	ss.dwCurrentState = dwState;
	ss.dwControlsAccepted = dwAccept;
	ss.dwWin32ExitCode = 0;
	ss.dwServiceSpecificExitCode = 0;
	ss.dwCheckPoint = 0;
	ss.dwWaitHint = 0;

	srvst = dwState;
	SetServiceStatus(hd, &ss);
}

DWORD GET_SERVICE_STATE()
{
	return srvst;
}
