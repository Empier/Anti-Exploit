#include <windows.h>  
#include <stdlib.h>  
#include <stdio.h>  
#include <winioctl.h>  
#include <string.h>  
#include <crtdbg.h>  
#include <assert.h>  
#include <fltuser.h>  
#include <dontuse.h>  
#include <Sddl.h>

#include "main.h"  
#include "Service.h"
#pragma comment(lib,"fltlib.lib")
#pragma comment(lib, "Advapi32.lib")

#define SCANNER_DEFAULT_REQUEST_COUNT       5  
#define SCANNER_DEFAULT_THREAD_COUNT        2  
#define SCANNER_MAX_THREAD_COUNT            64  

typedef struct _SCANNER_THREAD_CONTEXT {

	HANDLE Port;
	HANDLE Completion;

} SCANNER_THREAD_CONTEXT, *PSCANNER_THREAD_CONTEXT;

DWORD ScannerWorker(PSCANNER_THREAD_CONTEXT Context);


const char* S_NAME = "MsxSvc";
LPWSTR S_NAMEW = L"MsxSvc";
const char* S_DISP = "SaintSecurity Anti-Exploit Service";
const char* S_DESC = "SaintSecurity Anti-Exploit Service";
SERVICE_STATUS_HANDLE srvhd = 0;
DWORD                 srvst = SERVICE_STOPPED;

typedef BOOL(*UnloadDriver)(void);
typedef BOOL(*LoadDriver)(void);
UnloadDriver _UnloadDriver;
LoadDriver _LoadDriver;


HANDLE kernel = 0;
void Clean_Target();
void Change_Target(char val[]);

int main(int argc,char **argv)
{
	
	SERVICE_TABLE_ENTRYW STE[] =
	{
		{ S_NAMEW, (LPSERVICE_MAIN_FUNCTIONW)_tmain_service },
		{ NULL,NULL }
	};
	char S_BINARY[MAX_PATH] = { 0 };

	::GetModuleFileName(NULL, S_BINARY, MAX_PATH);

	if (argc == 2 && argv[1][0] == 'i')
	{
		ServiceInstall();
		
		return 0;
	}
	else if (argc == 2 && argv[1][0] == 'u')
	{
		ServiceUninstall();
		return 0;
	}
	else if (StartServiceCtrlDispatcherW(STE) == FALSE)
	{
		return -1;
	}

	return 0;
}


DWORD ScannerWorker(PSCANNER_THREAD_CONTEXT Context)
{
	BOOL result;
	DWORD outSize;
	LPOVERLAPPED pOvlp;
	ULONG_PTR key;
	HRESULT hr;
	PSCANNER_MESSAGE message;
	PSCANNER_NOTIFICATION notification;
	SCANNER_REPLY_MESSAGE replyMessage;
	char buf[1024];
	while (TRUE)
	{
		result = GetQueuedCompletionStatus(Context->Completion, &outSize, &key, &pOvlp, INFINITE);
		message = CONTAINING_RECORD(pOvlp, SCANNER_MESSAGE, Ovlp);
		if (!result)
		{
			printf("GetQueuedCompletionStatus error \n");
			break;
		}

		notification = &message->Notification;
		//printf("%d %s %d\n", notification->bCreate, notification->ProcessName, pOvlp->InternalHigh);
		sprintf(buf, "%d %s", notification->bCreate, notification->ProcessName);
		OutputDebugStringA(buf);

		ZeroMemory(&replyMessage, sizeof(SCANNER_REPLY_MESSAGE));
		replyMessage.ReplyHeader.Status = 0;
		replyMessage.ReplyHeader.MessageId = message->MessageHeader.MessageId;
		replyMessage.Reply.SafeToOpen = 6;
		CopyMemory(replyMessage.Reply.ReplyMsg, "12345678ab", 10);

		hr = FilterReplyMessage(Context->Port, (PFILTER_REPLY_HEADER)&replyMessage, sizeof(replyMessage));
		if (SUCCEEDED(hr))
		{
			//printf("Replied message\n");
		}
		else
		{
			printf("Scanner: Error replying message. Error = 0x%X\n", hr);
			break;
		}

		memset(&message->Ovlp, 0, sizeof(OVERLAPPED));
		hr = FilterGetMessage(Context->Port, &message->MessageHeader, FIELD_OFFSET(SCANNER_MESSAGE, Ovlp), &message->Ovlp);
		if (hr != HRESULT_FROM_WIN32(ERROR_IO_PENDING))
		{
			printf("FilterGetMessage error\n");
			break;
		}

	}
	//printf("Finish \n");
	delete message;
	return 0;
}
DWORD EnablePrivilege(TCHAR * privilegeStr)
{
	HANDLE hToken;			// process token
	TOKEN_PRIVILEGES tp;				// token provileges
	TOKEN_PRIVILEGES oldtp;			// old token privileges
	DWORD dwSize = sizeof(TOKEN_PRIVILEGES);
	LUID luid;

	if (!OpenProcessToken(GetCurrentProcess(),
		TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
		&hToken))
	{
		return GetLastError();
	}

	if (!LookupPrivilegeValue(NULL, privilegeStr, &luid))
	{
		CloseHandle(hToken);
		return GetLastError();
	}

	memset(&tp, 0, sizeof(tp));
	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	// Adjust Token privileges
	if (!AdjustTokenPrivileges(hToken,
		FALSE,
		&tp,
		sizeof(TOKEN_PRIVILEGES),
		&oldtp,
		&dwSize))
	{
		CloseHandle(hToken);
		return GetLastError();
	}

	CloseHandle(hToken);
	return ERROR_SUCCESS;
}
LONG SetMediumLevel()
{
	EnablePrivilege(("SeLoadDriverPrivilege"));
	EnablePrivilege(("SeDebugPrivilege"));
	EnablePrivilege(("SeTakeOwnershipPrivilege"));
	EnablePrivilege("SeSecurityPrivilege");
	EnablePrivilege("SeAssignPrimaryTokenPrivilege");
	EnablePrivilege("SeSystemEnvironmentPrivilege");
	return GetLastError();
}


void InitDriver(wchar_t val[])
{
	DWORD ret = 0;
	wchar_t dlldir[MAX_PATH];

	HKEY hKey;
	char key[256];
	char buf[128];
	DWORD size = 0;
	char *ptr = NULL;
	char *context = NULL;


	
	while (1)
	{
		kernel = CreateFileW(L"\\\\.\\Empire", 0xC0000000, 3u, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
		if ((DWORD)kernel != -1)
			break;
		OutputDebugStringA("EEEEEEEEEE");
		Sleep(1000);
	}
	wcscpy(dlldir, val);
	//wprintf(L"--%s\n", dlldir);

	DWORD cc = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x2000, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);
	DeviceIoControl(kernel, cc, (LPVOID)&dlldir, MAX_PATH, (LPVOID)&dlldir, MAX_PATH, &ret, 0);
	
	
	

	CloseHandle(kernel);

	Clean_Target();
	RegOpenKeyExA(HKEY_USERS, ".DEFAULT\\Software\\SaintSecurity\\MSX", 0, KEY_READ, &hKey);
	for (int i = 1; i < 100; i++)
	{
		sprintf(key, "Shield%03d", i);
		size = 128;
		int ret = RegQueryValueExA(hKey, key, 0, NULL, (LPBYTE)buf, &size);
		if (ret == 0)
		{
			ptr = strtok_s((char *)buf, ",", &context);
			ptr = strtok_s(NULL, ",", &context);
			OutputDebugStringA(ptr);
			Change_Target(ptr);
		}
	}
	RegCloseKey(hKey);


	//Change_Target();

}

void Change_Target(char val[])
{
	DWORD ret = -1;
	char processname[64];
	/*
	struct input
	{
	char processname[64];
	}*pinp;
	pinp = (input *)malloc(sizeof(input));
	*/
	kernel = CreateFileW(L"\\\\.\\Empire", 0xC0000000, 3u, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

	strcpy(processname, val);

	DWORD cc = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x2001, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);
	DeviceIoControl(kernel, cc, (LPVOID)&processname, 128, (LPVOID)&processname, 128, &ret, 0);

	CloseHandle(kernel);
	//free(pinp);
}

void Clean_Target()
{
	DWORD ret = 0;
	kernel = CreateFileW(L"\\\\.\\Empire", 0xC0000000, 3u, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

	DWORD cc = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x2002, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);
	DeviceIoControl(kernel, cc, (LPVOID)NULL, 0, (LPVOID)NULL, 0, &ret, 0);
	CloseHandle(kernel);
}




int _tmain_service(INT ARGC, LPSTR* ARGV)
{
	DWORD requestCount = SCANNER_DEFAULT_REQUEST_COUNT;
	DWORD threadCount = SCANNER_DEFAULT_THREAD_COUNT;
	HANDLE port, completion;
	HRESULT hr;
	DWORD threadId;
	PSCANNER_MESSAGE msg;
	HANDLE threads[SCANNER_MAX_THREAD_COUNT];
	SCANNER_THREAD_CONTEXT context;
	int i = 0;

	// 서비스가 외부 제어 명령(시작, 중지, 다시 시작... etc) 을 받을 때, 그것을 받을 수 있도록 콜백형식의
	// 함수를 등록하는 것이다.
	srvhd = RegisterServiceCtrlHandlerEx(S_NAME, _tmain_service_handler, NULL);
	if (srvhd == NULL)
		return -1;


	//MessageBoxA(NULL, "AAAA", "BBBB", MB_OK);
	SET_SERVICE_STATE(srvhd, SERVICE_START_PENDING);
	
	// 정상적으로 서비스가 시작되었다.
	SET_SERVICE_STATE(srvhd, SERVICE_RUNNING);

	SetMediumLevel();
	
	
	HKEY hKey;
	char str[MAX_PATH];
	wchar_t str_u[MAX_PATH];
	DWORD data_size = sizeof(str);


	
	data_size = sizeof(str);
	
	while (1)
	{
		int ret = RegOpenKeyExA(HKEY_USERS, ".DEFAULT\\Software\\SaintSecurity\\MSX", 0, KEY_READ||KEY_QUERY_VALUE, &hKey);

		if (ret == ERROR_SUCCESS)
		{
			RegQueryValueExA(hKey, "ProgramDir", 0, NULL, (LPBYTE)str, &data_size);
			RegCloseKey(hKey);
			
			break;
		}
		Sleep(1500);
	}
	strcat(str, "\\\x00");

	
	
	int nLen = MultiByteToWideChar(CP_ACP, 0, str, strlen(str), NULL, NULL);
	MultiByteToWideChar(CP_ACP, 0, str, strlen(str), str_u, nLen);
	str_u[nLen] = 0;
	wprintf(L"Init dir:%s\n", str_u);
	InitDriver(str_u);
	/*
	
	HMODULE MD=LoadLibrary(buf);
	
	sprintf(errors, "> %s %d\n", buf, MD);
	OutputDebugStringA(errors);
	
	
	_LoadDriver = (LoadDriver)GetProcAddress(MD, "LoadDriver");
	_UnloadDriver = (UnloadDriver)GetProcAddress(MD, "UnloadDriver");
	if((DWORD)_LoadDriver!=0 &&  (DWORD)_UnloadDriver!=0)
	{
		OutputDebugStringA("GOOD!");
	_LoadDriver();
	_UnloadDriver();
	}



	HKEY hKey;
	char str[MAX_PATH];
	wchar_t str_u[MAX_PATH];
	DWORD data_size = sizeof(str);


	
	data_size = sizeof(str);
	RegOpenKeyExA(HKEY_USERS, ".DEFAULT\\Software\\SaintSecurity\\MSX", 0, KEY_ALL_ACCESS, &hKey);
	int ret = RegQueryValueExA(hKey, "ProgramDir", 0, NULL, (LPBYTE)str, &data_size);
	strcat(str, "\\\x00");
	int nLen = MultiByteToWideChar(CP_ACP, 0, str, strlen(str), NULL, NULL);
	MultiByteToWideChar(CP_ACP, 0, str, strlen(str), str_u, nLen);
	str_u[nLen] = 0;
	wprintf(L"Init dir:%s\n", str_u);
	InitDriver(str_u);
	*/


	// 무한 루프를 돌면서 띵띵~ 소리를 낸다.
	while (GET_SERVICE_STATE() != SERVICE_STOPPED)
	{
		if (GET_SERVICE_STATE() == SERVICE_PAUSED)
		{
			Sleep(1000);
			continue;
		}


		
		hr = FilterConnectCommunicationPort(L"\\CommunicationPort", 0, NULL, 0, NULL, &port);
		if (IS_ERROR(hr))
		{

			printf("ERROR: Connecting to filter port: 0x%08x\n", hr);
			Sleep(1000);
			continue;
		}

		completion = CreateIoCompletionPort(port, NULL, 0, threadCount);
		if (completion == NULL)
		{

		//	printf("ERROR: Creating completion port: %d\n", GetLastError());
			CloseHandle(port);
			Sleep(1000);
			//getchar();
			//getchar();
			//return 3;
			continue;
		}

		context.Port = port;
		context.Completion = completion;



		for (i = 0; i < 2; i++)
		{

			threads[i] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ScannerWorker, &context, 0, &threadId);
			if (threads[i] == NULL)
			{
				hr = GetLastError();
				printf("ERROR: Couldn't create thread: %d\n", hr);
				goto main_cleanup;
			}

			for (int j = 0; j < 2; j++)
			{


				msg = new SCANNER_MESSAGE[sizeof(SCANNER_MESSAGE)];
				if (msg == NULL)
				{

					hr = ERROR_NOT_ENOUGH_MEMORY;
					goto main_cleanup;
				}

				memset(&msg->Ovlp, 0, sizeof(OVERLAPPED));

				hr = FilterGetMessage(port, &msg->MessageHeader, FIELD_OFFSET(SCANNER_MESSAGE, Ovlp), &msg->Ovlp);
				if (hr != HRESULT_FROM_WIN32(ERROR_IO_PENDING))
				{

					delete msg;
					goto main_cleanup;
				}
			}

		}
		hr = S_OK;


		WaitForMultipleObjectsEx(i, threads, TRUE, INFINITE, FALSE);

	main_cleanup:

		printf("Scanner:  All done. Result = 0x%08x\n", hr);

		CloseHandle(port);
		CloseHandle(completion);
		
		//getchar();
		//getchar();

		


		Sleep(1000);
		continue;
	}

	return 0;
}



DWORD WINAPI _tmain_service_handler(DWORD fdwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext)
{
	// 서비스라 좋은점이 있네, 시스템에서 발생하는 잡다구리한 이벤트들을 별로 힘들이지 않고
	// 이곳에서 받아다가 처리할 수 있다.

	switch (fdwControl)
	{
	case SERVICE_CONTROL_PAUSE:
		SET_SERVICE_STATE(srvhd, SERVICE_PAUSE_PENDING, 0);
		// 서비스를 일시 중지 시킨다.
		SET_SERVICE_STATE(srvhd, SERVICE_PAUSED);
		break;

	case SERVICE_CONTROL_CONTINUE:
		SET_SERVICE_STATE(srvhd, SERVICE_CONTINUE_PENDING, 0);
		// 일시 중지 시킨 서비스를 재개한다.
		SET_SERVICE_STATE(srvhd, SERVICE_RUNNING);
		break;

	case SERVICE_CONTROL_STOP:
		SET_SERVICE_STATE(srvhd, SERVICE_STOP_PENDING, 0);
		// 서비스를 멈춘다 (즉, 종료와 같은 의미)
		SET_SERVICE_STATE(srvhd, SERVICE_STOPPED);
		break;

	default:
		break;
	}

	return NO_ERROR;
}
