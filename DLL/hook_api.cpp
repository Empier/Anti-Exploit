#include <Windows.h>
#include <stdio.h>
#include "wintoastlib.h"
#include "main.h"
#include "resource.h"
#include <WinInet.h>
#include <OleAuto.h>
#include "resource.h"
#include "stsc_util.h"
#include "main.h"



LPVOID(WINAPI *HeapAllocNext)(HANDLE hHeap, DWORD  dwFlags, SIZE_T dwBytes);
BOOL(WINAPI *CreateProcessWNext) (LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes,
LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment,
LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
UINT(WINAPI *WinExecNext)(LPCSTR lpCmdLine, UINT   uCmdShow);
HINSTANCE(WINAPI *ShellExecuteWNext)(HWND    hwnd, LPCTSTR lpOperation,     LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd);
HMODULE(WINAPI *LoadLibraryExWNext)(LPCTSTR lpFileName, HANDLE  hFile,  DWORD  dwFlags);
HMODULE(WINAPI *GetModuleHandleWNext)(LPCTSTR lpModuleName);
int(*systemNext)(const char *command);
int(*_wsystemNext)(const wchar_t *command);
HRESULT(WINAPI *URLDownloadToFileWNext)(LPUNKNOWN pCaller, LPCTSTR szURL, LPCWSTR szFileName,  DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB);
HRESULT(WINAPI *URLDownloadToFileANext)(LPUNKNOWN pCaller, LPCSTR szURL, LPCSTR szFileName,  DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB);
BOOL(WINAPI *InternetReadFileNext)(HINTERNET hFile,  LPVOID lpBuffer,  DWORD dwNumberOfBytesToRead,  LPDWORD lpdwNumberOfBytesRead);
BOOL(WINAPI *InternetReadFileExWNext)( HINTERNET hFile,  LPINTERNET_BUFFERS lpBuffersOut,  DWORD dwFlags,  DWORD_PTR dwContext);
LPVOID(WINAPI *VirtualAllocNext)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flAllocationType, DWORD  flProtect);
HANDLE(WINAPI *HeapCreateNext)(DWORD  flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
BOOL(WINAPI *WriteProcessMemoryNext)(HANDLE  hProcess, LPVOID  lpBaseAddress, LPCVOID lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesWritten);
BOOL(WINAPI *VirtualProtectNext)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flNewProtect, PDWORD lpflOldProtect);
BOOL(WINAPI *SetProcessDEPPolicyNext)(DWORD dwFlags);

#ifdef _WIN64
extern "C" int __stdcall get_ret64(unsigned long long *ret,BYTE * opcode);
#endif

void Detect_Func(int type=0)
{
	switch (type)
	{
	case 0:
		strcpy(detect_name, "00000");
		
		break;
	case 1:
		strcpy(detect_name, "ROP Gadget Detect!");
		break;

	case 2:
		strcpy(detect_name, "Heap Execution Detect!");
		break;
	case 3:
		strcpy(detect_name, "Unsigned file Execution Detect!");
		break;
	}

	DialogBoxW(g_hDLL, (LPCTSTR)101, NULL, (DLGPROC)DialogProc); //101 -> IDD_DIALOG1

}
//
void vuln_check(unsigned long long ret)
{
	MEMORY_BASIC_INFORMATION mbi;
	BYTE call_op;
	BYTE call_op2;

	call_op = *((BYTE *)ret - 5);
	call_op2 = *((BYTE *)ret - 6);


	VirtualQueryEx(GetCurrentProcess(), (LPCVOID)ret, &mbi, 0x1c);

	if (call_op != 0xE8 && call_op2 != 0xFF)
	{
		Detect_Func(1);
	}
	else if (mbi.Type == MEM_PRIVATE) // Heap Execution  << Stack aslr DEP ON
	{
		Detect_Func(2);
	}

}


LPVOID WINAPI HeapAllocCallback(HANDLE hHeap, DWORD  dwFlags, SIZE_T dwBytes)
{

	LPVOID ret = HeapAllocNext(hHeap, dwFlags, dwBytes);
	
	return ret;
}

BOOL WINAPI CreateProcessWCallback(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes,
	LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment,
	LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
{
	//wprintf(L"%s %s\n", lpApplicationName, lpCommandLine);

	if (!_stricmp(PROCESS_NAME, "wscript.exe") && bit == FALSE)
	{
		DWORD isSigned = VerifyEmbeddedSignature(lpApplicationName);
		if (isSigned)
		{
			Detect_Func(3);
		}
	}

	return CreateProcessWNext(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);

}

UINT WINAPI WinExecCallback(LPCSTR lpCmdLine, UINT   uCmdShow)
{
	unsigned long long ret;
	ret = (unsigned long long)_ReturnAddress();
	vuln_check(ret);

	return WinExecNext(lpCmdLine, uCmdShow);

}

HINSTANCE ShellExecuteWCallback(HWND    hwnd, LPCTSTR lpOperation,     LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd)
{
	unsigned long long ret;

	ret = (unsigned long long)_ReturnAddress();
	vuln_check(ret);

	return ShellExecuteWNext(hwnd, lpOperation, lpFile, lpParameters,lpDirectory,nShowCmd);

}

HMODULE WINAPI LoadLibraryExWCallback(LPCTSTR lpFileName, _Reserved_ HANDLE  hFile,  DWORD  dwFlags)
{
#ifdef SP
	printf("LoadLibraryExW Called...\n");
#endif
	return LoadLibraryExWNext(lpFileName, hFile, dwFlags);
}

HMODULE WINAPI GetModuleHandleWCallback(LPCTSTR lpModuleName)
{
#ifdef SP
	printf("GetModuleHandleW Called...\n");
#endif
	return GetModuleHandleWNext(lpModuleName);
}

int systemCallback(const char *command)
{
#ifdef SP
	printf("system Called...\n");
#endif
	return systemNext(command);
}

int _wsystemCallback(const wchar_t *command)
{
#ifdef SP
	printf("_wsystem Called...\n");
#endif
	return _wsystemNext(command);
}

HRESULT WINAPI URLDownloadToFileWCallback(LPUNKNOWN pCaller, LPCTSTR szURL, LPCWSTR szFileName, _Reserved_ DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB)
{
#ifdef SP
	printf("URLDownloadToFileW Called...\n");
#endif
	unsigned long long ret;

	ret = (unsigned long long)_ReturnAddress();
	vuln_check(ret);
	return URLDownloadToFileWNext(pCaller,szURL,szFileName,dwReserved,lpfnCB);
}

HRESULT WINAPI URLDownloadToFileACallback(LPUNKNOWN pCaller, LPCSTR szURL, LPCSTR szFileName, _Reserved_ DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB)
{
#ifdef SP
	printf("URLDownloadToFileA Called...\n");
#endif
	unsigned long long ret;

	ret = (unsigned long long)_ReturnAddress();
	vuln_check(ret);

	return URLDownloadToFileANext(pCaller, szURL, szFileName, dwReserved, lpfnCB);
}

BOOL WINAPI InternetReadFileCallback(HINTERNET hFile, _Out_ LPVOID lpBuffer,  DWORD dwNumberOfBytesToRead, _Out_ LPDWORD lpdwNumberOfBytesRead)
{
#ifdef SP
	//printf("InternetReadFile Called...\n");
#endif
	BOOL ret = InternetReadFileNext(hFile, lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead);
	//printf("Content: %s\n", lpBuffer);
	return ret;
}

BOOL WINAPI InternetReadFileExWCallback( HINTERNET hFile, _Out_ LPINTERNET_BUFFERSW lpBuffersOut,  DWORD dwFlags,  DWORD_PTR dwContext)
{
#ifdef SP
	//printf("InternetReadFileExW Called...\n");
#endif
	BOOL ret= InternetReadFileExWNext(hFile, lpBuffersOut, dwFlags, dwContext);
	//wprintf(L"S_Content: %ws\n", lpBuffersOut->lpvBuffer);
	return ret;
}

LPVOID WINAPI VirtualAllocCallback(LPVOID lpAddress, SIZE_T dwSize, DWORD  flAllocationType, DWORD  flProtect)
{
#ifdef SP
	//printf("VirtualAlloc Called...\n");
#endif
	unsigned long long ret;

	ret = (unsigned long long)_ReturnAddress();
	vuln_check(ret);

	LPVOID ret2 = VirtualAllocNext(lpAddress, dwSize, flAllocationType, flProtect);
	return ret2;
}

HANDLE WINAPI HeapCreateCallback(DWORD  flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
{
#ifdef SP
	//printf("HeapCreate Called...\n");
#endif
	HANDLE ret = HeapCreateNext(flOptions, dwInitialSize, dwMaximumSize);
	return ret;
}

BOOL WINAPI WriteProcessMemoryCallback(HANDLE  hProcess, LPVOID  lpBaseAddress, LPCVOID lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesWritten)
{
#ifdef SP
	//printf("WriteProcessMemory Called...\n");
#endif
	unsigned long long ret;

	ret = (unsigned long long)_ReturnAddress();
	vuln_check(ret);
	BOOL ret2 = WriteProcessMemoryNext(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
	return ret2;
}

BOOL WINAPI VirtualProtectCallback(LPVOID lpAddress, SIZE_T dwSize, DWORD  flNewProtect, PDWORD lpflOldProtect)
{
#ifdef SP
	//printf("VirtualProtect Called...\n");
#endif
	unsigned long long ret;

	ret = (unsigned long long)_ReturnAddress();
	
#ifdef _WIN64
	
	
	//get_ret64(&ret, &call_op);

	


#else
	/*
	DWORD ret;
	BYTE call_op;
	BYTE call_op2;
	DWORD _esp;

	__asm
	{
		mov eax, esp;
		mov _esp, eax
	}
	*/
	ret = (DWORD)_ReturnAddress();
	

#endif


	vuln_check(ret);



	BOOL OriFunc_ret = VirtualProtectNext(lpAddress, dwSize, flNewProtect, lpflOldProtect);
	return OriFunc_ret;

}

BOOL WINAPI SetProcessDEPPolicyCallback(DWORD dwFlags)
{
#ifdef SP
	//printf("SetProcessDEPPolicy Called...\n");
#endif
	unsigned long long ret;

	ret = (unsigned long long)_ReturnAddress();
	vuln_check(ret);

	BOOL ret2 = SetProcessDEPPolicyNext(dwFlags);
	return ret2;
}

