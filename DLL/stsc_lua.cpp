extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}
#include <time.h>
#include <Windows.h>
#include <WinInet.h>

#include "main.h"
#include "MinHook.h"
#include "hook_api.h"

#pragma comment(lib, "lua53.lib")
lua_State *GL = NULL;



int lua_rand(lua_State* L)
{
int a = 0;
int c = 0;
lua_Integer b = 0;
a = (int)luaL_checkinteger(L, 1);
c = (int)luaL_checkinteger(L, 2);
srand(time(NULL));

b = rand() % (c - a + 1) + a;
lua_pushinteger(L, b);

return 1;
}

int lua_allocconsole(lua_State* L)
{
	FILE *out;
	AllocConsole();
	freopen_s(&out, "CON", "w", stdout);
	SetConsoleTitleA("Console");
	return 0;
}
int lua_showtext(lua_State* L)
{
	int color = 0;
	char str[256] = { 0x00, };

	strcpy(str, (char *)luaL_checkstring(L, 1));
	

	printf("str:%s\n", str);
	return 0;
}

int lua_sleep(lua_State* L)
{
	int delay = 0;
	
	delay = (int)luaL_checkinteger(L, 1);

	Sleep(delay);
	return 0;
}
int lua_get_os(lua_State* L)
{
	lua_pushinteger(L, OSver); //0 is not supported.
	return 1;
}
int lua_get_bit(lua_State* L)
{
	lua_pushinteger(L, bit);  //bit True(1) is x32
	return 1;
}

int lua_get_processname(lua_State* L)
{
	lua_pushstring(L, PROCESS_NAME); 
	return 1;
}

int lua_get_filename(lua_State* L)
{
	lua_pushstring(L, FILE_NAME);
	return 1;
}

int lua_hook_kernel32_createprocessw(lua_State* L)
{
	int ret = 0;
	ret = MH_CreateHookApiEx(L"kernel32.dll", "CreateProcessW", &CreateProcessWCallback, reinterpret_cast<LPVOID*>(&CreateProcessWNext), NULL);
	lua_pushinteger(L, ret); 

	MH_EnableHook(&CreateProcessW);

	return 1;
}

int lua_hook_kernel32_winexec(lua_State* L)
{
	int ret = 0;
	ret = MH_CreateHookApiEx(L"kernel32.dll", "WinExec", &WinExecCallback, reinterpret_cast<LPVOID*>(&WinExecNext), NULL);
	lua_pushinteger(L, ret);
	
	MH_EnableHook(&WinExec);

	return 1;
}
int lua_hook_kernel32_heapcreate(lua_State* L)
{
	int ret = 0;
	ret = MH_CreateHookApiEx(L"kernel32.dll", "HeapCreate", &HeapCreateCallback, reinterpret_cast<LPVOID*>(&HeapCreateNext), NULL);
	lua_pushinteger(L, ret);

	MH_EnableHook(&HeapCreate);
	return 1;
}
int lua_hook_kernel32_virtualalloc(lua_State* L)
{
	int ret = 0;
	ret = MH_CreateHookApiEx(L"kernel32.dll", "VirtualAlloc", &VirtualAllocCallback, reinterpret_cast<LPVOID*>(&VirtualAllocNext), NULL);
	lua_pushinteger(L, ret);
	MH_EnableHook(&VirtualAlloc);
	return 1;
}
int lua_hook_kernel32_virtualprotect(lua_State* L)
{
	int ret = 0;
	ret = MH_CreateHookApiEx(L"kernel32.dll", "VirtualProtect", &VirtualProtectCallback, reinterpret_cast<LPVOID*>(&VirtualProtectNext), NULL);
	lua_pushinteger(L, ret);
	MH_EnableHook(&VirtualProtect);
	return 1;
}
int lua_hook_kernel32_writeprocessmemory(lua_State* L)
{
	int ret = 0;
	ret = MH_CreateHookApiEx(L"kernel32.dll", "WriteProcessMemory", &WriteProcessMemoryCallback, reinterpret_cast<LPVOID*>(&WriteProcessMemoryNext), NULL);
	lua_pushinteger(L, ret);
	MH_EnableHook(&WriteProcessMemory);
	return 1;
}
int lua_hook_urlmon_urldownloadtofilew(lua_State* L)
{
	int ret = 0;
	ret = MH_CreateHookApiEx(L"urlmon.dll", "URLDownloadToFileW", &URLDownloadToFileWCallback, reinterpret_cast<LPVOID*>(&URLDownloadToFileWNext), NULL);
	lua_pushinteger(L, ret);
	MH_EnableHook(&URLDownloadToFileW);
	return 1;
}
int lua_hook_urlmon_urldownloadtofilea(lua_State* L)
{
	int ret = 0;
	ret = MH_CreateHookApiEx(L"urlmon.dll", "URLDownloadToFileA", &URLDownloadToFileACallback, reinterpret_cast<LPVOID*>(&URLDownloadToFileANext), NULL);
	lua_pushinteger(L, ret);
	MH_EnableHook(&URLDownloadToFileA);
	return 1;
}
int lua_hook_wininet_internetreadfile(lua_State* L)
{
	int ret = 0;
	ret = MH_CreateHookApiEx(L"wininet.dll", "InternetReadFile", &InternetReadFileCallback, reinterpret_cast<LPVOID*>(&InternetReadFileNext), NULL);
	lua_pushinteger(L, ret);
	MH_EnableHook(&InternetReadFile);
	return 1;
}
int lua_hook_wininet_internetreadfileexw(lua_State* L)
{
	int ret = 0;
	ret = MH_CreateHookApiEx(L"wininet.dll", "InternetReadFileExW", &InternetReadFileExWCallback, reinterpret_cast<LPVOID*>(&InternetReadFileExWNext), NULL);
	lua_pushinteger(L, ret);
	MH_EnableHook(&InternetReadFileExW);
	return 1;
}
int lua_hook_shell32_shellexecutew(lua_State* L)
{
	int ret = 0;
	ret = MH_CreateHookApiEx(L"shell32.dll", "ShellExecuteW", &ShellExecuteWCallback, reinterpret_cast<LPVOID*>(&ShellExecuteWNext), NULL);
	lua_pushinteger(L, ret);
	MH_EnableHook(&ShellExecuteW);
	return 1;
}



/*if (MH_CreateHookApiEx(L"kernel32.dll", "CreateProcessW", &CreateProcessWCallback, reinterpret_cast<LPVOID*>(&CreateProcessWNext), NULL) != MH_OK)
	{
		return 1;
	}
	if (MH_CreateHookApiEx(L"kernel32.dll", "WinExec", &WinExecCallback, reinterpret_cast<LPVOID*>(&WinExecNext), NULL) != MH_OK)
	{
		return 1;
	}
	if (MH_CreateHookApiEx(L"kernel32.dll", "HeapCreate", &HeapCreateCallback, reinterpret_cast<LPVOID*>(&HeapCreateNext), NULL) != MH_OK)
	{
		return 1;
	}
	if (MH_CreateHookApiEx(L"kernel32.dll", "VirtualAlloc", &VirtualAllocCallback, reinterpret_cast<LPVOID*>(&VirtualAllocNext), NULL) != MH_OK)
	{
		return 1;
	}
	if (MH_CreateHookApiEx(L"kernel32.dll", "VirtualProtect", &VirtualProtectCallback, reinterpret_cast<LPVOID*>(&VirtualProtectNext), NULL) != MH_OK)
	{
		return 1;
	}
	if (MH_CreateHookApiEx(L"kernel32.dll", "WriteProcessMemory", &WriteProcessMemoryCallback, reinterpret_cast<LPVOID*>(&WriteProcessMemoryNext), NULL) != MH_OK)
	{
		return 1;
	}

	if (MH_CreateHookApiEx(L"urlmon.dll", "URLDownloadToFileW", &URLDownloadToFileWCallback, reinterpret_cast<LPVOID*>(&URLDownloadToFileWNext),NULL) != MH_OK)
	{
	    return 1;
	}
	if (MH_CreateHookApiEx(L"urlmon.dll", "URLDownloadToFileA", &URLDownloadToFileACallback, reinterpret_cast<LPVOID*>(&URLDownloadToFileANext),NULL) != MH_OK)
	{
		return 1;
	}

	if (MH_CreateHookApiEx(L"wininet.dll", "InternetReadFile", &InternetReadFileCallback, reinterpret_cast<LPVOID*>(&InternetReadFileNext), NULL) != MH_OK)
	{
		return 1;
	}

	if (MH_CreateHookApiEx(L"wininet.dll", "InternetReadFileExW", &InternetReadFileExWCallback, reinterpret_cast<LPVOID*>(&InternetReadFileExWNext), NULL) != MH_OK)
	{
		return 1;
	}

	if (MH_CreateHookApiEx(L"shell32.dll", "ShellExecuteW", &ShellExecuteWCallback, reinterpret_cast<LPVOID*>(&ShellExecuteWNext), NULL) != MH_OK)
	{
		return 1;
	}
	
	if (MH_EnableHook(&WinExec) != MH_OK)
	{
		return 1;
	}
	
	if (MH_EnableHook(&CreateProcessW) != MH_OK)
	{
		return 1;
	}
	
	if (MH_EnableHook(&HeapCreate) != MH_OK)
	{
		return 1;
	}
	if (MH_EnableHook(&VirtualAlloc) != MH_OK)
	{
		return 1;
	}
	//VirtualProtect x64 Iexplore.exe error
	
	if (MH_EnableHook(&VirtualProtect) != MH_OK)
	{
		return 1;
	}
	
	if (MH_EnableHook(&WriteProcessMemory) != MH_OK)
	{
		return 1;
	}
	
	if (MH_EnableHook(&URLDownloadToFileW) != MH_OK)
	{
		return 1;
	}
	if (MH_EnableHook(&URLDownloadToFileA) != MH_OK)
	{
		return 1;
	}
	
	if (MH_EnableHook(&InternetReadFile) != MH_OK)
	{
		return 1;
	}
	if (MH_EnableHook(&InternetReadFileExW) != MH_OK)
	{
		return 1;
	}
	
	if (MH_EnableHook(&ShellExecuteW) != MH_OK)
	{
		return 1;
	}*/
unsigned WINAPI start_script(void *args)
{
	char tempdir[MAX_PATH] = { 0x00, };
	char dir[MAX_PATH] = { 0x00, };
	lua_State *L;
	L = luaL_newstate();
	if ((INT)L == 0 || (INT)L == -1)
		return 0;


	luaL_openlibs(L);
	lua_register(L, "allocconsole", lua_allocconsole);
	lua_register(L, "showtext", lua_showtext);
	lua_register(L, "sleep", lua_sleep);
	lua_register(L, "rand", lua_rand);
	lua_register(L, "get_os", lua_get_os);
	lua_register(L, "get_bit", lua_get_bit);
	lua_register(L, "get_processname", lua_get_processname); //test.exe
	lua_register(L, "get_filename", lua_get_filename);//C:\\~~stscae32.dll

	lua_register(L, "hook_kernel32_createprocessw", lua_hook_kernel32_createprocessw);
	lua_register(L, "hook_kernel32_winexec", lua_hook_kernel32_winexec);
	lua_register(L, "hook_kernel32_heapcreate", lua_hook_kernel32_heapcreate);
	lua_register(L, "hook_kernel32_virtualalloc", lua_hook_kernel32_virtualalloc);
	lua_register(L, "hook_kernel32_virtualprotect", lua_hook_kernel32_virtualprotect);
	lua_register(L, "hook_kernel32_writeprocessmemory", lua_hook_kernel32_writeprocessmemory);
	lua_register(L, "hook_urlmon_urldownloadtofilew", lua_hook_urlmon_urldownloadtofilew);
	lua_register(L, "hook_urlmon_urldownloadtofilea", lua_hook_urlmon_urldownloadtofilea);
	lua_register(L, "hook_wininet_internetreadfile", lua_hook_wininet_internetreadfile);
	lua_register(L, "hook_wininet_internetreadfileexw", lua_hook_wininet_internetreadfileexw);
	lua_register(L, "hook_shell32_shellexecutew", lua_hook_shell32_shellexecutew);



	GL = lua_newthread(L);



	strcat(tempdir, (char *)args);
	//luaL_dofile(L, tempdir);
	if (luaL_dofile(L, tempdir))
	{
		//Failed
		printf("ERR: %s\n",(char *)lua_tostring(L, -1));
	}

	//lua_close(GL);
	GL = 0;
	lua_close(L);

	return 0;
}
