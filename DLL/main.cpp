#include <WinSock2.h>
#include <tchar.h>
#include <process.h>
#include <cstdio>
#include <WinInet.h>
#include <time.h>
#include <tlhelp32.h>

#include "main.h"
#include "resource.h"
#include "hook_api.h"
#include "stsc_lua.h"
#include "stsc_util.h"

#include "MinHook.h"



int OSver = 0;
BOOL bit;
char FILE_NAME[MAX_PATH];
char PROCESS_NAME[MAX_PATH];

HMODULE g_hDLL = NULL;
HANDLE g_Thread = NULL;

char ProgramDir[MAX_PATH];
char LogDir[MAX_PATH];
char detect_name[256];


int WriteLog(wchar_t content)
{
	FILE *fp = fopen(LogDir, "a+");
	fwrite((const void *)content, 4, 1, fp);
	
	return 0;

}


unsigned WINAPI start_hooks(void *args)
{
	HKEY    hKey;
	DWORD   data_type;
	DWORD   data_size;
	
	OSver = What_is_this_OS();

	if (OSver == 0)
	{
		return 1; //Not Supported OS
	}
	else
	{
		if (!RegOpenKeyExW(HKEY_USERS, L".DEFAULT\\Software\\SaintSecurity\\MSX", 0, KEY_QUERY_VALUE, &hKey))
		{
			memset(ProgramDir, 0, sizeof(ProgramDir));
			
			data_size = sizeof(ProgramDir);
			RegQueryValueExA(hKey,                  
				"ProgramDir",                   
				0,                                    // 옵션 항상 0   
				&data_type,                           // 얻어진 데이터 타입  
				(BYTE*)ProgramDir,                  // 얻어진 데이터  
				(DWORD *)&data_size                  // 얻어진 데이터 크기   
			);
			RegCloseKey(hKey);
		}
	}
	sprintf(LogDir,"%s%s", ProgramDir, "\\Logs\\Logs.log");

	GetModuleFileNameA(0, PROCESS_NAME, MAX_PATH);
	
	for (int i = strlen(PROCESS_NAME); i > 0; i--)
	{
		if (PROCESS_NAME[i] == '\\')
		{
			strcpy(PROCESS_NAME, PROCESS_NAME + i + 1);
			break;
		}
	}
	
	GetModuleFileNameA(g_hDLL, FILE_NAME, MAX_PATH);
	
	//printf("PROCESS_NAME : %s\nDLL_PATH : %s\n",PROCESS_NAME,FILE_NAME);

	DWORD PPID=GetParentProcessId(); //부모아이디 구하기 - 나중에 커널로

	IsWow64Process(GetCurrentProcess(), &bit);
	
	/* 후킹 동기화 문제 / 커널 이미지 로드 되는 DLL 별로 후킹으로 개선 요함 */
	



	if (MH_Initialize() != MH_OK)
	{
		return 1;
	}

	if (MH_CreateHook(&CreateProcessW, &CreateProcessWCallback,
		reinterpret_cast<LPVOID*>(&CreateProcessWNext)) != MH_OK)
	{
		return 1;
	}
	if (MH_CreateHook(&WinExec, &WinExecCallback,
		reinterpret_cast<LPVOID*>(&WinExecNext)) != MH_OK)
	{
		return 1;
	}
	if (MH_CreateHook(&HeapCreate, &HeapCreateCallback,
		reinterpret_cast<LPVOID*>(&HeapCreateNext)) != MH_OK)
	{
		return 1;
	}
	if (MH_CreateHook(&VirtualAlloc, &VirtualAllocCallback,
		reinterpret_cast<LPVOID*>(&VirtualAllocNext)) != MH_OK)
	{
		return 1;
	}
	if (MH_CreateHook(&VirtualProtect, &VirtualProtectCallback,
		reinterpret_cast<LPVOID*>(&VirtualProtectNext)) != MH_OK)
	{
		return 1;
	}
	if (MH_CreateHook(&WriteProcessMemory, &WriteProcessMemoryCallback,
		reinterpret_cast<LPVOID*>(&WriteProcessMemoryNext)) != MH_OK)
	{
		return 1;
	}
	

	if (MH_CreateHookApiEx(L"urlmon.dll", "URLDownloadToFileW", &URLDownloadToFileWCallback, reinterpret_cast<LPVOID*>(&URLDownloadToFileWNext),NULL) != MH_OK)
	{
	    return 1;
	}
	if (MH_CreateHookApiEx(L"urlmon.dll", "URLDownloadToFileA", &URLDownloadToFileACallback, reinterpret_cast<LPVOID*>(&URLDownloadToFileANext),NULL) != MH_OK)
	{
		return 1;
	}

	if (MH_EnableHook(&WinExec) != MH_OK)
	{
		return 1;
	}
	if (MH_EnableHook(&CreateProcessW) != MH_OK)
	{
		return 1;
	}
	if (MH_EnableHook(&HeapCreate) != MH_OK)
	{
		return 1;
	}
	if (MH_EnableHook(&VirtualAlloc) != MH_OK)
	{
		return 1;
	}
	if (MH_EnableHook(&VirtualProtect) != MH_OK)
	{
		return 1;
	}
	if (MH_EnableHook(&WriteProcessMemory) != MH_OK)
	{
		return 1;
	}
	if (MH_EnableHook(&URLDownloadToFileW) != MH_OK)
	{
		return 1;
	}
	if (MH_EnableHook(&URLDownloadToFileA) != MH_OK)
	{
		return 1;
	}



	/*
	//use polyhook due to licensing issue
	HookAPI("kernel32.dll", "CreateProcessW", CreateProcessWCallback, (PVOID*)&CreateProcessWNext, 1);
	HookAPI("kernel32.dll", "WinExec", WinExecCallback, (PVOID*)&WinExecNext, 1);
	HookAPI("kernel32.dll", "HeapCreate", HeapCreateCallback, (PVOID*)&HeapCreateNext, 1);
	HookAPI("kernel32.dll", "VirtualAlloc", VirtualAllocCallback, (PVOID*)&VirtualAllocNext, 1);
	HookAPI("kernel32.dll", "VirtualProtect", VirtualProtectCallback, (PVOID*)&VirtualProtectNext, 1);
	HookAPI("kernel32.dll", "WriteProcessMemory", WriteProcessMemoryCallback, (PVOID*)&WriteProcessMemoryNext, 1);
	HookAPI("kernel32.dll", "SetProcessDEPPolicy", SetProcessDEPPolicyCallback, (PVOID*)&SetProcessDEPPolicyNext, 1);
	Sleep(2000);
	HookAPI("wininet.dll", "InternetReadFile", InternetReadFileCallback, (PVOID*)&InternetReadFileNext, 1);
	HookAPI("wininet.dll", "InternetReadFileExW", InternetReadFileExWCallback, (PVOID*)&InternetReadFileExWNext, 1);
	HookAPI("urlmon.dll", "URLDownloadToFileW", URLDownloadToFileWCallback, (PVOID*)&URLDownloadToFileWNext, 1);
	HookAPI("urlmon.dll", "URLDownloadToFileA", URLDownloadToFileACallback, (PVOID*)&URLDownloadToFileANext, 1);
	HookAPI("shell32.dll", "ShellExecuteW", ShellExecuteWCallback, (PVOID*)&ShellExecuteWNext, 1);
	*/




	//HookAPI("msvcrt.dll", "LoadLibraryExW", LoadLibraryExWCallback, (PVOID*)&LoadLibraryExWNext, 1);
	//HookAPI("msvcrt.dll", "GetModuleHandleW", GetModuleHandleWCallback, (PVOID*)&GetModuleHandleWNext, 1);
	//HookAPI("msvcrt.dll", "_wsystem", _wsystemCallback, (PVOID*)&_wsystemNext, 1);
	//HookAPI("msvcrt.dll", "system", systemCallback, (PVOID*)&systemNext, 1);

	//HeapAlloc -> 테스트 필요
	//NtSetinformationProcess -> DEP 설정 테스트
	
	if (!_stricmp(PROCESS_NAME, "wscript.exe"))
	{
		if (bit == TRUE)//x32
		{	
		}
		else
		{

		}
	}
	

	return 0;
}
/*
LONG CALLBACK MyUnhandledExceptionHandler(EXCEPTION_POINTERS *lpExceptionInfo)
{
	printf("================== Exception ===================\r\n");
	printf("Exception Code : 0x%08X\r\n",
		lpExceptionInfo->ExceptionRecord->ExceptionCode);
	printf("Exception Address : 0x%08P\r\n",
		lpExceptionInfo->ExceptionRecord->ExceptionAddress);

	DWORD   dwEbp = 0, dwOldEbp = 0;

	dwEbp = lpExceptionInfo->ContextRecord->ebp rbp;
	printf("EBP Register : 0x%08x\r\n", dwEbp);
	printf("CallStack :\r\n");

	for (INT nIndex = 0; nIndex < 10; nIndex++)
	{
		printf("\t%d th Stack : 0x%08x \r\n", nIndex + 1, *(LPDWORD)(dwEbp + 4));
		dwOldEbp = dwEbp;
		dwEbp = *(LPDWORD)(dwEbp);
		if ((dwEbp % 4) != 0 || dwOldEbp > dwEbp) // 잘못된 값이 나올때까지 추적  
		{
			break;
		}
	}

 

	return EXCEPTION_EXECUTE_HANDLER;
}
*/

BOOL CALLBACK DialogProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM IParam) //탐지 메시지는 나중에 exe 서비스로. sys 드라이버 올리는 문제도 포함
{
	switch (iMessage)
	{
	
	case WM_PAINT:
		

		return TRUE;
	case WM_INITDIALOG:	
		SetDlgItemTextA(hDlg, IDC_EDIT1, detect_name);
		return TRUE;
	case WM_COMMAND:
		switch (wParam)
		{
		case IDOK:
		case IDCANCEL:
			EndDialog(hDlg, 0);
			exit(0);
			return TRUE;
		}
		break;
	}
	return FALSE;
}

BOOL APIENTRY DllMain(HMODULE hModul, DWORD ul_reason_for_ca, LPVOID lpReserve)
{
	FILE* out = 0;
	WSADATA wsadata;
	switch (ul_reason_for_ca)
	{
	case DLL_PROCESS_ATTACH:
		g_hDLL = hModul;
		DisableThreadLibraryCalls(hModul);
		g_Thread = GetCurrentThread();
		if (SP) 
		{
			AllocConsole();
			freopen_s(&out, "CON", "w", stdout);
			SetConsoleTitleA("Console");
		}
		WSAStartup(MAKEWORD(2, 2), &wsadata);
		_beginthreadex(NULL, NULL, start_hooks, NULL, NULL, NULL);
		
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:

		break;
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}


/*
//시스템의 중요 API가 JMP 또는 RET가 아닌 CALL 명령에서 호출되도록 합니다.
//코드영역에서 실행되야합니다.
/*
StackNX: 스택에 속한 메모리 주소를 실행 가능으로 표시하기 위해 메모리 보호 API(예: VirtualProtect) 호출을 차단합니다.

StackPivot: 스택 주소가 변경되었는지 탐지합니다. 익스플로잇은 대개 가짜 또는 ROP 체인을 포함하는 정교하게 제작된 스택 메모리를 가리키도록 ESP 레지스터를 수정합니다.

RopCall: 시스템의 중요 API가 JMP 또는 RET가 아닌 CALL 명령에서 호출되도록 합니다.

RopFlow: 시스템의 중요 API가 호출될 때 스택에서 반환 주소의 실행을 시뮬레이션합니다. RET 주소가 다른 중요한 API를 가리키는 지 또는 실행 가능으로 올바르게 표시되지 않은 메모리를 가리키는 지 여부를 확인합니다. 경우 중 하나가 참이면 ROP 공격입니다. 성능에 미치는 영향을 피하기 위해 허용되는 최대 명령 수를 시뮬레이션합니다.

RopHeap: ROP 호출(RET)을 사용하여 나중에 실행되는 힙에 메모리 보호 API 호출을 거부합니다.
*/

