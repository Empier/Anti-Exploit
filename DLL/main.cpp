#include <WinSock2.h>
#include <tchar.h>
#include <process.h>
#include <cstdio>
#include <WinInet.h>
#include <time.h>
#include <tlhelp32.h>

#include "main.h"
#include "resource.h"
#include "hook_api.h"
#include "stsc_lua.h"
#include "stsc_util.h"

#include "MinHook.h"
#include <Ntsecapi.h>



int OSver = 0;
BOOL bit;
char FILE_NAME[MAX_PATH];
char PROCESS_NAME[MAX_PATH];

HMODULE g_hDLL = NULL;
HANDLE g_Thread = NULL;

char ProgramDir[MAX_PATH];
char LogDir[MAX_PATH];
char detect_name[256];


char Lua_Name[MAX_PATH];



int WriteLog(wchar_t content)
{
	FILE *fp = fopen(LogDir, "a+");
	fwrite((const void *)content, 4, 1, fp);
	
	return 0;

}


unsigned WINAPI start_hooks(void *args)
{
	HKEY    hKey;
	DWORD   data_type;
	DWORD   data_size;
	
	OSver = What_is_this_OS();

	if (OSver == 0)
	{
		return 1; //Not Supported OS
	}
	else
	{
		if (!RegOpenKeyExW(HKEY_USERS, L".DEFAULT\\Software\\SaintSecurity\\MSX", 0, KEY_QUERY_VALUE, &hKey))
		{
			memset(ProgramDir, 0, sizeof(ProgramDir));
			
			data_size = sizeof(ProgramDir);
			RegQueryValueExA(hKey,                  
				"ProgramDir",                   
				0,                                    // 옵션 항상 0   
				&data_type,                           // 얻어진 데이터 타입  
				(BYTE*)ProgramDir,                  // 얻어진 데이터  
				(DWORD *)&data_size                  // 얻어진 데이터 크기   
			);
			RegCloseKey(hKey);
		}
	}
	sprintf(LogDir,"%s%s", ProgramDir, "\\Logs\\Logs.log");

	GetModuleFileNameA(0, PROCESS_NAME, MAX_PATH);
	
	for (int i = strlen(PROCESS_NAME); i > 0; i--)
	{
		if (PROCESS_NAME[i] == '\\')
		{
			strcpy(PROCESS_NAME, PROCESS_NAME + i + 1);
			break;
		}
	}
	
	GetModuleFileNameA(g_hDLL, FILE_NAME, MAX_PATH);
	

	char key[MAX_PATH];
	char buf[MAX_PATH];
	DWORD size = 0;
	char *ptr = NULL;
	char *context = NULL;
	if (!RegOpenKeyExA(HKEY_USERS, ".DEFAULT\\Software\\SaintSecurity\\MSX", 0, KEY_QUERY_VALUE, &hKey))
	{
		for (int i = 1; i < 100; i++)
		{
			sprintf(key, "Shield%03d", i);
			size = MAX_PATH;
			int ret = RegQueryValueExA(hKey, key, 0, NULL, (LPBYTE)buf, &size);
			if (ret == 0)
			{
				ptr = strtok_s((char *)buf, ",", &context);
				ptr = strtok_s(NULL, ",", &context);
				//printf("%s %s\n", ptr, PROCESS_NAME);
				if (!stricmp(ptr, PROCESS_NAME))
				{
					ptr = strtok_s(NULL, ",", &context);
					strcpy(Lua_Name, ptr);
					//printf("Lua_Name: %s\n", Lua_Name);
				}
			}
		}
		RegCloseKey(hKey);
	}


	char ScriptDir[MAX_PATH];
	sprintf(ScriptDir, "%s%s%s", ProgramDir, "\\Script\\",Lua_Name);
	start_script(ScriptDir);
	//printf("PROCESS_NAME : %s\nDLL_PATH : %s\n",PROCESS_NAME,FILE_NAME);

	DWORD PPID=GetParentProcessId(); //부모아이디 구하기 - 나중에 커널로

	
	
	/* 후킹 동기화 문제 / 커널 이미지 로드 되는 DLL 별로 후킹으로 개선 요함 */
	
	

	
	
	//HeapAlloc -> 테스트 필요
	//NtSetinformationProcess -> DEP 설정 테스트
	
	if (!_stricmp(PROCESS_NAME, "wscript.exe"))
	{
		if (bit == TRUE)//x32
		{	
		}
		else
		{
		}
	}

	return 0;
}


BOOL CALLBACK DialogProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM IParam) //탐지 메시지는 나중에 exe 서비스로. sys 드라이버 올리는 문제도 포함
{
	switch (iMessage)
	{
	
	case WM_PAINT:
		

		return TRUE;
	case WM_INITDIALOG:	
		SetDlgItemTextA(hDlg, IDC_EDIT1, detect_name);
		return TRUE;
	case WM_COMMAND:
		switch (wParam)
		{
		case IDOK:
		case IDCANCEL:
			EndDialog(hDlg, 0);
			exit(0);
			return TRUE;
		}
		break;
	}
	return FALSE;
}

typedef const UNICODE_STRING * PCUNICODE_STRING;

typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA {
	ULONG Flags;
	PCUNICODE_STRING FullDllName;
	PCUNICODE_STRING BaseDllName;
	PVOID DllBase;
	ULONG SizeOfImage;
} LDR_DLL_LOADED_NOTIFICATION_DATA, *PLDR_DLL_LOADED_NOTIFICATION_DATA;
typedef struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA {
	ULONG Flags;
	PCUNICODE_STRING FullDllName;
	PCUNICODE_STRING BaseDllName;
	PVOID DllBase;
	ULONG SizeOfImage;
} LDR_DLL_UNLOADED_NOTIFICATION_DATA, *PLDR_DLL_UNLOADED_NOTIFICATION_DATA;
typedef union _LDR_DLL_NOTIFICATION_DATA {
	LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
	LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;
} LDR_DLL_NOTIFICATION_DATA, *PLDR_DLL_NOTIFICATION_DATA;
typedef const _LDR_DLL_NOTIFICATION_DATA * PCLDR_DLL_NOTIFICATION_DATA;

typedef VOID(CALLBACK * PLDR_DLL_NOTIFICATION_FUNCTION)( ULONG NotificationReason,PCLDR_DLL_NOTIFICATION_DATA NotificationData,PVOID Context);
typedef NTSTATUS(NTAPI * PLDR_REGISTER_DLL_NOTIFICATION)(ULONG Flags,PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,PVOID Context,PVOID *Cookie);
typedef NTSTATUS(NTAPI * PLDR_UNREGISTER_DLL_NOTIFICATION)(PVOID Cookie);

static PLDR_REGISTER_DLL_NOTIFICATION    LdrRegisterDllNotification = 0;
static PLDR_UNREGISTER_DLL_NOTIFICATION  LdrUnRegisterDllNotification = 0;
static PVOID cookie;

static VOID CALLBACK LdrDllNotification( ULONG NotificationReason,PCLDR_DLL_NOTIFICATION_DATA NotificationData,PVOID Context)
{
	WCHAR szPath[MAX_PATH];
	WCHAR szName[MAX_PATH];
	if (NotificationReason == 1)
	{
		lstrcpyn(szName, NotificationData->Loaded.BaseDllName->Buffer, NotificationData->Loaded.BaseDllName->Length);
		/*
		if (wcsicmp(szName, L"kernel32.dll") == 0)
		{
			if (MH_CreateHookApiEx(L"kernel32.dll", "CreateProcessW", &CreateProcessWCallback, reinterpret_cast<LPVOID*>(&CreateProcessWNext), NULL) != MH_OK)
			{
				return;
			}
			else
			{
				if (MH_EnableHook(&CreateProcessW) != MH_OK)
				{
					return;
				}
			}
			if (MH_CreateHookApiEx(L"kernel32.dll", "WinExec", &WinExecCallback, reinterpret_cast<LPVOID*>(&WinExecNext), NULL) != MH_OK)
			{
				return;
			}
			else
			{
				if (MH_EnableHook(&WinExec) != MH_OK)
				{
					return;
				}
			}
			if (MH_CreateHookApiEx(L"kernel32.dll", "HeapCreate", &HeapCreateCallback, reinterpret_cast<LPVOID*>(&HeapCreateNext), NULL) != MH_OK)
			{
				return;
			}
			else
			{
				if (MH_EnableHook(&HeapCreate) != MH_OK)
				{
					return;
				}
			}
			if (MH_CreateHookApiEx(L"kernel32.dll", "VirtualAlloc", &VirtualAllocCallback, reinterpret_cast<LPVOID*>(&VirtualAllocNext), NULL) != MH_OK)
			{
				return;
			}
			else
			{
				if (MH_EnableHook(&VirtualAlloc) != MH_OK)
				{
					return;
				}
			}
			if (MH_CreateHookApiEx(L"kernel32.dll", "VirtualProtect", &VirtualProtectCallback, reinterpret_cast<LPVOID*>(&VirtualProtectNext), NULL) != MH_OK)
			{
				return;
			}
			else
			{
				if (MH_EnableHook(&VirtualProtect) != MH_OK)
				{
					return;
				}
			}
			if (MH_CreateHookApiEx(L"kernel32.dll", "WriteProcessMemory", &WriteProcessMemoryCallback, reinterpret_cast<LPVOID*>(&WriteProcessMemoryNext), NULL) != MH_OK)
			{
				return;
			}
			else
			{
				if (MH_EnableHook(&WriteProcessMemory) != MH_OK)
				{
					return;
				}
			}

		}
		else if (wcsicmp(szName, L"urlmon.dll") == 0)
		{
			if (MH_CreateHookApiEx(L"urlmon.dll", "URLDownloadToFileW", &URLDownloadToFileWCallback, reinterpret_cast<LPVOID*>(&URLDownloadToFileWNext), NULL) != MH_OK)
			{
				return;
			}
			else
			{
				if (MH_EnableHook(&URLDownloadToFileW) != MH_OK)
				{
					return;
				}
			}
			if (MH_CreateHookApiEx(L"urlmon.dll", "URLDownloadToFileA", &URLDownloadToFileACallback, reinterpret_cast<LPVOID*>(&URLDownloadToFileANext), NULL) != MH_OK)
			{
				return;
			}
			else
			{
				if (MH_EnableHook(&URLDownloadToFileA) != MH_OK)
				{
					return;
				}
			}
			
		}
		else if (wcsicmp(szName, L"wininet.dll") == 0)
		{
			if (MH_CreateHookApiEx(L"wininet.dll", "InternetReadFile", &InternetReadFileCallback, reinterpret_cast<LPVOID*>(&InternetReadFileNext), NULL) != MH_OK)
			{
				return;
			}
			else
			{
				if (MH_EnableHook(&InternetReadFile) != MH_OK)
				{
					return;
				}
			}
			if (MH_CreateHookApiEx(L"wininet.dll", "InternetReadFileExW", &InternetReadFileExWCallback, reinterpret_cast<LPVOID*>(&InternetReadFileExWNext), NULL) != MH_OK)
			{
				return;
			}
			else
			{
				if (MH_EnableHook(&InternetReadFileExW) != MH_OK)
				{
					return;
				}
			}
		}
		else if (wcsicmp(szName, L"shell32.dll") == 0)
		{
			if (MH_CreateHookApiEx(L"shell32.dll", "ShellExecuteW", &ShellExecuteWCallback, reinterpret_cast<LPVOID*>(&ShellExecuteWNext), NULL) != MH_OK)
			{
				return;
			}
			else
			{
				if (MH_EnableHook(&ShellExecuteW) != MH_OK)
				{
					return;
				}
			}
		}
		*/
		//if(SP)
		//wprintf(L"%x %s %s\n", NotificationData->Loaded.DllBase, NotificationData->Loaded.FullDllName->Buffer, NotificationData->Loaded.BaseDllName->Buffer);
		
	}
}


BOOL APIENTRY DllMain(HMODULE hModul, DWORD ul_reason_for_ca, LPVOID lpReserve)
{
	FILE* out = 0;
	WSADATA wsadata;
	switch (ul_reason_for_ca)
	{
	case DLL_PROCESS_ATTACH:
		g_hDLL = hModul;
		DisableThreadLibraryCalls(hModul);
		g_Thread = GetCurrentThread();
		IsWow64Process(GetCurrentProcess(), &bit);
		if (SP) 
		{
			AllocConsole();
			freopen_s(&out, "CON", "w", stdout);
			SetConsoleTitleA("Console");
		}
		WSAStartup(MAKEWORD(2, 2), &wsadata);
		
		if (MH_Initialize() != MH_OK)
		{
			return 1;
		}

		LdrRegisterDllNotification = (PLDR_REGISTER_DLL_NOTIFICATION)GetProcAddress(GetModuleHandle(L"ntdll.dll"),("LdrRegisterDllNotification"));
		LdrUnRegisterDllNotification = (PLDR_UNREGISTER_DLL_NOTIFICATION)GetProcAddress(GetModuleHandle(L"ntdll.dll"),("LdrUnRegisterDllNotification"));
		
		if (LdrRegisterDllNotification)
		{
			LdrRegisterDllNotification(0, LdrDllNotification,0, &cookie);
		}


		


		_beginthreadex(NULL, NULL, start_hooks, NULL, NULL, NULL);
		
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:

		break;
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}

/*
StackNX: 스택에 속한 메모리 주소를 실행 가능으로 표시하기 위해 메모리 보호 API(예: VirtualProtect) 호출을 차단합니다.

StackPivot: 스택 주소가 변경되었는지 탐지합니다. 익스플로잇은 대개 가짜 또는 ROP 체인을 포함하는 정교하게 제작된 스택 메모리를 가리키도록 ESP 레지스터를 수정합니다.

RopCall: 시스템의 중요 API가 JMP 또는 RET가 아닌 CALL 명령에서 호출되도록 합니다.

RopFlow: 시스템의 중요 API가 호출될 때 스택에서 반환 주소의 실행을 시뮬레이션합니다. RET 주소가 다른 중요한 API를 가리키는 지 또는 실행 가능으로 올바르게 표시되지 않은 메모리를 가리키는 지 여부를 확인합니다. 경우 중 하나가 참이면 ROP 공격입니다. 성능에 미치는 영향을 피하기 위해 허용되는 최대 명령 수를 시뮬레이션합니다.

RopHeap: ROP 호출(RET)을 사용하여 나중에 실행되는 힙에 메모리 보호 API 호출을 거부합니다.
*/

